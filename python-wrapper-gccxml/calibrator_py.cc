#define private public
#define protected public
#include "python_util.h"
// This file has been generated by Py++.

#include "boost/python.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "boost/python/suite/indexing/map_indexing_suite.hpp"

#include "common_util.h"

#include "log_util.h"

#include "LoadSave.h"

#include "Prediction/Calibrate/Calibrator.h"

#include "Prediction/Calibrate/CalibratorFactory.h"

#include "Numeric/Vector/Vector.h"

namespace bp = boost::python;

struct LoadSave_wrapper : gezi::LoadSave, bp::wrapper< gezi::LoadSave > {

LoadSave_wrapper(gezi::LoadSave const & arg )
: gezi::LoadSave( arg )
, bp::wrapper< gezi::LoadSave >(){
// copy constructor

}

LoadSave_wrapper()
: gezi::LoadSave()
, bp::wrapper< gezi::LoadSave >(){
// null constructor

}

virtual bool CustomLoad( ::std::string path ) {
if( bp::override func_CustomLoad = this->get_override( "CustomLoad" ) )
return func_CustomLoad( path );
else
return this->gezi::LoadSave::CustomLoad( path );
}


bool default_CustomLoad( ::std::string path ) {
return gezi::LoadSave::CustomLoad( path );
}

virtual void CustomSave( ::std::string path ) {
if( bp::override func_CustomSave = this->get_override( "CustomSave" ) )
func_CustomSave( path );
else
this->gezi::LoadSave::CustomSave( path );
}


void default_CustomSave( ::std::string path ) {
gezi::LoadSave::CustomSave( path );
}

virtual bool Load( ::std::string path ) {
if( bp::override func_Load = this->get_override( "Load" ) )
return func_Load( path );
else
return this->gezi::LoadSave::Load( path );
}


bool default_Load( ::std::string path ) {
return gezi::LoadSave::Load( path );
}

virtual bool LoadJson( ::std::string file ) {
if( bp::override func_LoadJson = this->get_override( "LoadJson" ) )
return func_LoadJson( file );
else
return this->gezi::LoadSave::LoadJson( file );
}


bool default_LoadJson( ::std::string file ) {
return gezi::LoadSave::LoadJson( file );
}

virtual bool LoadText( ::std::string file ) {
if( bp::override func_LoadText = this->get_override( "LoadText" ) )
return func_LoadText( file );
else
return this->gezi::LoadSave::LoadText( file );
}


bool default_LoadText( ::std::string file ) {
return gezi::LoadSave::LoadText( file );
}

virtual bool LoadXml( ::std::string file ) {
if( bp::override func_LoadXml = this->get_override( "LoadXml" ) )
return func_LoadXml( file );
else
return this->gezi::LoadSave::LoadXml( file );
}


bool default_LoadXml( ::std::string file ) {
return gezi::LoadSave::LoadXml( file );
}

virtual ::std::string Name(  ) {
if( bp::override func_Name = this->get_override( "Name" ) )
return func_Name(  );
else
return this->gezi::LoadSave::Name(  );
}


::std::string default_Name(  ) {
return gezi::LoadSave::Name( );
}

virtual void Save( ::std::string path ) {
if( bp::override func_Save = this->get_override( "Save" ) )
func_Save( path );
else
this->gezi::LoadSave::Save( path );
}


void default_Save( ::std::string path ) {
gezi::LoadSave::Save( path );
}

virtual void SaveJson( ::std::string file ) {
if( bp::override func_SaveJson = this->get_override( "SaveJson" ) )
func_SaveJson( file );
else
this->gezi::LoadSave::SaveJson( file );
}


void default_SaveJson( ::std::string file ) {
gezi::LoadSave::SaveJson( file );
}

virtual void SaveText( ::std::string file ) {
if( bp::override func_SaveText = this->get_override( "SaveText" ) )
func_SaveText( file );
else
this->gezi::LoadSave::SaveText( file );
}


void default_SaveText( ::std::string file ) {
gezi::LoadSave::SaveText( file );
}

virtual void SaveXml( ::std::string file ) {
if( bp::override func_SaveXml = this->get_override( "SaveXml" ) )
func_SaveXml( file );
else
this->gezi::LoadSave::SaveXml( file );
}


void default_SaveXml( ::std::string file ) {
gezi::LoadSave::SaveXml( file );
}

};

struct Calibrator_wrapper : gezi::Calibrator, bp::wrapper< gezi::Calibrator > {

Calibrator_wrapper(gezi::Calibrator const & arg )
: gezi::Calibrator( arg )
, bp::wrapper< gezi::Calibrator >(){
// copy constructor

}

Calibrator_wrapper()
: gezi::Calibrator()
, bp::wrapper< gezi::Calibrator >(){
// null constructor

}

virtual void FinishTraining(  ) {
if( bp::override func_FinishTraining = this->get_override( "FinishTraining" ) )
func_FinishTraining(  );
else
this->gezi::Calibrator::FinishTraining(  );
}


void default_FinishTraining(  ) {
gezi::Calibrator::FinishTraining( );
}

virtual ::std::string Name(  ) {
if( bp::override func_Name = this->get_override( "Name" ) )
return func_Name(  );
else
return this->gezi::Calibrator::Name(  );
}


::std::string default_Name(  ) {
return gezi::Calibrator::Name( );
}

virtual ::Float PredictProbability( ::Float output ) {
if( bp::override func_PredictProbability = this->get_override( "PredictProbability" ) )
return func_PredictProbability( output );
else
return this->gezi::Calibrator::PredictProbability( output );
}


::Float default_PredictProbability( ::Float output ) {
return gezi::Calibrator::PredictProbability( output );
}

virtual void ProcessTrainingExample( ::Float output, bool clicked, ::Float weight=1.0e+0 ) {
if( bp::override func_ProcessTrainingExample = this->get_override( "ProcessTrainingExample" ) )
func_ProcessTrainingExample( output, clicked, weight );
else
this->gezi::Calibrator::ProcessTrainingExample( output, clicked, weight );
}


void default_ProcessTrainingExample( ::Float output, bool clicked, ::Float weight=1.0e+0 ) {
gezi::Calibrator::ProcessTrainingExample( output, clicked, weight );
}

virtual bool CustomLoad( ::std::string path ) {
if( bp::override func_CustomLoad = this->get_override( "CustomLoad" ) )
return func_CustomLoad( path );
else
return this->gezi::LoadSave::CustomLoad( path );
}


bool default_CustomLoad( ::std::string path ) {
return gezi::LoadSave::CustomLoad( path );
}

virtual void CustomSave( ::std::string path ) {
if( bp::override func_CustomSave = this->get_override( "CustomSave" ) )
func_CustomSave( path );
else
this->gezi::LoadSave::CustomSave( path );
}


void default_CustomSave( ::std::string path ) {
gezi::LoadSave::CustomSave( path );
}

virtual bool Load( ::std::string path ) {
if( bp::override func_Load = this->get_override( "Load" ) )
return func_Load( path );
else
return this->gezi::LoadSave::Load( path );
}


bool default_Load( ::std::string path ) {
return gezi::LoadSave::Load( path );
}

virtual bool LoadJson( ::std::string file ) {
if( bp::override func_LoadJson = this->get_override( "LoadJson" ) )
return func_LoadJson( file );
else
return this->gezi::LoadSave::LoadJson( file );
}


bool default_LoadJson( ::std::string file ) {
return gezi::LoadSave::LoadJson( file );
}

virtual bool LoadText( ::std::string file ) {
if( bp::override func_LoadText = this->get_override( "LoadText" ) )
return func_LoadText( file );
else
return this->gezi::LoadSave::LoadText( file );
}


bool default_LoadText( ::std::string file ) {
return gezi::LoadSave::LoadText( file );
}

virtual bool LoadXml( ::std::string file ) {
if( bp::override func_LoadXml = this->get_override( "LoadXml" ) )
return func_LoadXml( file );
else
return this->gezi::LoadSave::LoadXml( file );
}


bool default_LoadXml( ::std::string file ) {
return gezi::LoadSave::LoadXml( file );
}

virtual void Save( ::std::string path ) {
if( bp::override func_Save = this->get_override( "Save" ) )
func_Save( path );
else
this->gezi::LoadSave::Save( path );
}


void default_Save( ::std::string path ) {
gezi::LoadSave::Save( path );
}

virtual void SaveJson( ::std::string file ) {
if( bp::override func_SaveJson = this->get_override( "SaveJson" ) )
func_SaveJson( file );
else
this->gezi::LoadSave::SaveJson( file );
}


void default_SaveJson( ::std::string file ) {
gezi::LoadSave::SaveJson( file );
}

virtual void SaveText( ::std::string file ) {
if( bp::override func_SaveText = this->get_override( "SaveText" ) )
func_SaveText( file );
else
this->gezi::LoadSave::SaveText( file );
}


void default_SaveText( ::std::string file ) {
gezi::LoadSave::SaveText( file );
}

virtual void SaveXml( ::std::string file ) {
if( bp::override func_SaveXml = this->get_override( "SaveXml" ) )
func_SaveXml( file );
else
this->gezi::LoadSave::SaveXml( file );
}


void default_SaveXml( ::std::string file ) {
gezi::LoadSave::SaveXml( file );
}

};

struct CalibratorWrapper_wrapper : gezi::CalibratorWrapper, bp::wrapper< gezi::CalibratorWrapper > {

CalibratorWrapper_wrapper(gezi::CalibratorWrapper const & arg )
: gezi::CalibratorWrapper( arg )
, bp::wrapper< gezi::CalibratorWrapper >(){
// copy constructor

}

CalibratorWrapper_wrapper()
: gezi::CalibratorWrapper()
, bp::wrapper< gezi::CalibratorWrapper >(){
// null constructor

}

virtual void FinishTraining(  ) {
if( bp::override func_FinishTraining = this->get_override( "FinishTraining" ) )
func_FinishTraining(  );
else
this->gezi::CalibratorWrapper::FinishTraining(  );
}


void default_FinishTraining(  ) {
gezi::CalibratorWrapper::FinishTraining( );
}

virtual void ProcessTrainingExample( ::Float output, bool clicked, ::Float weight ) {
if( bp::override func_ProcessTrainingExample = this->get_override( "ProcessTrainingExample" ) )
func_ProcessTrainingExample( output, clicked, weight );
else
this->gezi::CalibratorWrapper::ProcessTrainingExample( output, clicked, weight );
}


void default_ProcessTrainingExample( ::Float output, bool clicked, ::Float weight ) {
gezi::CalibratorWrapper::ProcessTrainingExample( output, clicked, weight );
}

virtual void TrainModel( ::gezi::CalibratorStore & data ){
if( bp::override func_TrainModel = this->get_override( "TrainModel" ) )
func_TrainModel( boost::ref(data) );
else
this->gezi::CalibratorWrapper::TrainModel( boost::ref(data) );
}

virtual bool CustomLoad( ::std::string path ) {
if( bp::override func_CustomLoad = this->get_override( "CustomLoad" ) )
return func_CustomLoad( path );
else
return this->gezi::LoadSave::CustomLoad( path );
}


bool default_CustomLoad( ::std::string path ) {
return gezi::LoadSave::CustomLoad( path );
}

virtual void CustomSave( ::std::string path ) {
if( bp::override func_CustomSave = this->get_override( "CustomSave" ) )
func_CustomSave( path );
else
this->gezi::LoadSave::CustomSave( path );
}


void default_CustomSave( ::std::string path ) {
gezi::LoadSave::CustomSave( path );
}

virtual bool Load( ::std::string path ) {
if( bp::override func_Load = this->get_override( "Load" ) )
return func_Load( path );
else
return this->gezi::LoadSave::Load( path );
}


bool default_Load( ::std::string path ) {
return gezi::LoadSave::Load( path );
}

virtual bool LoadJson( ::std::string file ) {
if( bp::override func_LoadJson = this->get_override( "LoadJson" ) )
return func_LoadJson( file );
else
return this->gezi::LoadSave::LoadJson( file );
}


bool default_LoadJson( ::std::string file ) {
return gezi::LoadSave::LoadJson( file );
}

virtual bool LoadText( ::std::string file ) {
if( bp::override func_LoadText = this->get_override( "LoadText" ) )
return func_LoadText( file );
else
return this->gezi::LoadSave::LoadText( file );
}


bool default_LoadText( ::std::string file ) {
return gezi::LoadSave::LoadText( file );
}

virtual bool LoadXml( ::std::string file ) {
if( bp::override func_LoadXml = this->get_override( "LoadXml" ) )
return func_LoadXml( file );
else
return this->gezi::LoadSave::LoadXml( file );
}


bool default_LoadXml( ::std::string file ) {
return gezi::LoadSave::LoadXml( file );
}

virtual ::std::string Name(  ) {
if( bp::override func_Name = this->get_override( "Name" ) )
return func_Name(  );
else
return this->gezi::Calibrator::Name(  );
}


::std::string default_Name(  ) {
return gezi::Calibrator::Name( );
}

virtual ::Float PredictProbability( ::Float output ) {
if( bp::override func_PredictProbability = this->get_override( "PredictProbability" ) )
return func_PredictProbability( output );
else
return this->gezi::Calibrator::PredictProbability( output );
}


::Float default_PredictProbability( ::Float output ) {
return gezi::Calibrator::PredictProbability( output );
}

virtual void Save( ::std::string path ) {
if( bp::override func_Save = this->get_override( "Save" ) )
func_Save( path );
else
this->gezi::LoadSave::Save( path );
}


void default_Save( ::std::string path ) {
gezi::LoadSave::Save( path );
}

virtual void SaveJson( ::std::string file ) {
if( bp::override func_SaveJson = this->get_override( "SaveJson" ) )
func_SaveJson( file );
else
this->gezi::LoadSave::SaveJson( file );
}


void default_SaveJson( ::std::string file ) {
gezi::LoadSave::SaveJson( file );
}

virtual void SaveText( ::std::string file ) {
if( bp::override func_SaveText = this->get_override( "SaveText" ) )
func_SaveText( file );
else
this->gezi::LoadSave::SaveText( file );
}


void default_SaveText( ::std::string file ) {
gezi::LoadSave::SaveText( file );
}

virtual void SaveXml( ::std::string file ) {
if( bp::override func_SaveXml = this->get_override( "SaveXml" ) )
func_SaveXml( file );
else
this->gezi::LoadSave::SaveXml( file );
}


void default_SaveXml( ::std::string file ) {
gezi::LoadSave::SaveXml( file );
}

};

BOOST_PYTHON_MODULE(libcalibrator){
DEF_VEC(ivec);
DEF_VEC(dvec);
DEF_VEC(uvec);
DEF_VEC(svec);
DEF_VEC(ulvec);
DEF_MAP(id_map);
DEF_MAP(sd_map);
DEF_MAP(si_map);
DEF_MAP(ss_map);
DEF_PAIR(ii_pair);
DEF_PAIR(si_pair);
DEF_PAIR(wsi_pair);
DEF_VEC(si_pair_vec);
DEF_VEC(wsi_pair_vec);
DEF_SET(iset);
DEF_SET(lset);
DEF_SET(ulset);

{ //::std::vector< int >
typedef bp::class_< std::vector< int > > ivec_exposer_t;
ivec_exposer_t ivec_exposer = ivec_exposer_t( "ivec" );
bp::scope ivec_scope( ivec_exposer );
ivec_exposer.def( bp::vector_indexing_suite< ::std::vector< int >, true >() )
VEC_METHOD(::std::vector< int >);
}

{ //::std::vector< gezi::CalibratorStore::Node >
typedef bp::class_< std::vector< gezi::CalibratorStore::Node > > vector_less__gezi_scope_CalibratorStore_scope_Node__greater__exposer_t;
vector_less__gezi_scope_CalibratorStore_scope_Node__greater__exposer_t vector_less__gezi_scope_CalibratorStore_scope_Node__greater__exposer = vector_less__gezi_scope_CalibratorStore_scope_Node__greater__exposer_t( "vector_less__gezi_scope_CalibratorStore_scope_Node__greater_" );
bp::scope vector_less__gezi_scope_CalibratorStore_scope_Node__greater__scope( vector_less__gezi_scope_CalibratorStore_scope_Node__greater__exposer );
//WARNING: the next line of code will not compile, because "::gezi::CalibratorStore::Node" does not have operator== !
//         vector_less__gezi_scope_CalibratorStore_scope_Node__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< gezi::CalibratorStore::Node > >() );
}

{ //::std::vector< double >
typedef bp::class_< std::vector< double > > vector_less__double__greater__exposer_t;
vector_less__double__greater__exposer_t vector_less__double__greater__exposer = vector_less__double__greater__exposer_t( "vector_less__double__greater_" );
bp::scope vector_less__double__greater__scope( vector_less__double__greater__exposer );
vector_less__double__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< double >, true >() )
VEC_METHOD(::std::vector< double >);
}

{ //::std::vector< bool >
typedef bp::class_< std::vector< bool > > BitArray_exposer_t;
BitArray_exposer_t BitArray_exposer = BitArray_exposer_t( "BitArray" );
bp::scope BitArray_scope( BitArray_exposer );
BitArray_exposer.def( bp::vector_indexing_suite< ::std::vector< bool >, true >() )
VEC_METHOD(::std::vector< bool >);
}

bp::class_< std::map< int, double > >("map_less__int_comma__double__greater_")
.def( bp::map_indexing_suite< ::std::map< int, double >, true >() )
MAP_METHOD(::std::map< int COMMA  double >);

bp::class_< LoadSave_wrapper >( "LoadSave" )
.def(
"CustomLoad"
, (bool ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::CustomLoad)
, (bool ( LoadSave_wrapper::* )( ::std::string ) )(&LoadSave_wrapper::default_CustomLoad)
, ( bp::arg("path") ) )
.def(
"CustomSave"
, (void ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::CustomSave)
, (void ( LoadSave_wrapper::* )( ::std::string ) )(&LoadSave_wrapper::default_CustomSave)
, ( bp::arg("path") ) )
.def(
"Load"
, (bool ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::Load)
, (bool ( LoadSave_wrapper::* )( ::std::string ) )(&LoadSave_wrapper::default_Load)
, ( bp::arg("path") ) )
.def(
"LoadJson"
, (bool ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::LoadJson)
, (bool ( LoadSave_wrapper::* )( ::std::string ) )(&LoadSave_wrapper::default_LoadJson)
, ( bp::arg("file") ) )
.def(
"LoadText"
, (bool ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::LoadText)
, (bool ( LoadSave_wrapper::* )( ::std::string ) )(&LoadSave_wrapper::default_LoadText)
, ( bp::arg("file") ) )
.def(
"LoadXml"
, (bool ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::LoadXml)
, (bool ( LoadSave_wrapper::* )( ::std::string ) )(&LoadSave_wrapper::default_LoadXml)
, ( bp::arg("file") ) )
.def(
"Name"
, (::std::string ( ::gezi::LoadSave::* )(  ) )(&::gezi::LoadSave::Name)
, (::std::string ( LoadSave_wrapper::* )(  ) )(&LoadSave_wrapper::default_Name) )
.def(
"Save"
, (void ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::Save)
, (void ( LoadSave_wrapper::* )( ::std::string ) )(&LoadSave_wrapper::default_Save)
, ( bp::arg("path") ) )
.def(
"SaveJson"
, (void ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::SaveJson)
, (void ( LoadSave_wrapper::* )( ::std::string ) )(&LoadSave_wrapper::default_SaveJson)
, ( bp::arg("file") ) )
.def(
"SaveText"
, (void ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::SaveText)
, (void ( LoadSave_wrapper::* )( ::std::string ) )(&LoadSave_wrapper::default_SaveText)
, ( bp::arg("file") ) )
.def(
"SaveXml"
, (void ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::SaveXml)
, (void ( LoadSave_wrapper::* )( ::std::string ) )(&LoadSave_wrapper::default_SaveXml)
, ( bp::arg("file") ) );

{ //::gezi::Calibrator
typedef bp::class_< Calibrator_wrapper, bp::bases< gezi::LoadSave > > Calibrator_exposer_t;
Calibrator_exposer_t Calibrator_exposer = Calibrator_exposer_t( "Calibrator" );
bp::scope Calibrator_scope( Calibrator_exposer );
{ //::gezi::Calibrator::FinishTraining

typedef void ( ::gezi::Calibrator::*FinishTraining_function_type )(  ) ;
typedef void ( Calibrator_wrapper::*default_FinishTraining_function_type )(  ) ;

Calibrator_exposer.def(
"FinishTraining"
, FinishTraining_function_type(&::gezi::Calibrator::FinishTraining)
, default_FinishTraining_function_type(&Calibrator_wrapper::default_FinishTraining) );

}
{ //::gezi::Calibrator::Name

typedef ::std::string ( ::gezi::Calibrator::*Name_function_type )(  ) ;
typedef ::std::string ( Calibrator_wrapper::*default_Name_function_type )(  ) ;

Calibrator_exposer.def(
"Name"
, Name_function_type(&::gezi::Calibrator::Name)
, default_Name_function_type(&Calibrator_wrapper::default_Name) );

}
{ //::gezi::Calibrator::PredictProbability

typedef ::Float ( ::gezi::Calibrator::*PredictProbability_function_type )( ::Float ) ;
typedef ::Float ( Calibrator_wrapper::*default_PredictProbability_function_type )( ::Float ) ;

Calibrator_exposer.def(
"PredictProbability"
, PredictProbability_function_type(&::gezi::Calibrator::PredictProbability)
, default_PredictProbability_function_type(&Calibrator_wrapper::default_PredictProbability)
, ( bp::arg("output") ) );

}
{ //::gezi::Calibrator::ProcessTrainingExample

typedef void ( ::gezi::Calibrator::*ProcessTrainingExample_function_type )( ::Float,bool,::Float ) ;
typedef void ( Calibrator_wrapper::*default_ProcessTrainingExample_function_type )( ::Float,bool,::Float ) ;

Calibrator_exposer.def(
"ProcessTrainingExample"
, ProcessTrainingExample_function_type(&::gezi::Calibrator::ProcessTrainingExample)
, default_ProcessTrainingExample_function_type(&Calibrator_wrapper::default_ProcessTrainingExample)
, ( bp::arg("output"), bp::arg("clicked"), bp::arg("weight")=1.0e+0 ) );

}
{ //::gezi::Calibrator::Train

typedef void ( ::gezi::Calibrator::*Train_function_type )( ::std::vector< double > const &,::gezi::Instances const & ) ;

Calibrator_exposer.def(
"Train"
, Train_function_type( &::gezi::Calibrator::Train )
, ( bp::arg("predictions"), bp::arg("instances") ) );

}
{ //::gezi::Calibrator::Train

typedef void ( ::gezi::Calibrator::*Train_function_type )( ::Fvec const &,::BitArray const &,::Fvec const & ) ;

Calibrator_exposer.def(
"Train"
, Train_function_type( &::gezi::Calibrator::Train )
, ( bp::arg("scores"), bp::arg("labels"), bp::arg("weights") ) );

}
{ //::gezi::Calibrator::Train

typedef void ( ::gezi::Calibrator::*Train_function_type )( ::Fvec const &,::BitArray const & ) ;

Calibrator_exposer.def(
"Train"
, Train_function_type( &::gezi::Calibrator::Train )
, ( bp::arg("scores"), bp::arg("labels") ) );

}
{ //::gezi::LoadSave::CustomLoad

typedef bool ( ::gezi::LoadSave::*CustomLoad_function_type )( ::std::string ) ;
typedef bool ( Calibrator_wrapper::*default_CustomLoad_function_type )( ::std::string ) ;

Calibrator_exposer.def(
"CustomLoad"
, CustomLoad_function_type(&::gezi::LoadSave::CustomLoad)
, default_CustomLoad_function_type(&Calibrator_wrapper::default_CustomLoad)
, ( bp::arg("path") ) );

}
{ //::gezi::LoadSave::CustomSave

typedef void ( ::gezi::LoadSave::*CustomSave_function_type )( ::std::string ) ;
typedef void ( Calibrator_wrapper::*default_CustomSave_function_type )( ::std::string ) ;

Calibrator_exposer.def(
"CustomSave"
, CustomSave_function_type(&::gezi::LoadSave::CustomSave)
, default_CustomSave_function_type(&Calibrator_wrapper::default_CustomSave)
, ( bp::arg("path") ) );

}
{ //::gezi::LoadSave::Load

typedef bool ( ::gezi::LoadSave::*Load_function_type )( ::std::string ) ;
typedef bool ( Calibrator_wrapper::*default_Load_function_type )( ::std::string ) ;

Calibrator_exposer.def(
"Load"
, Load_function_type(&::gezi::LoadSave::Load)
, default_Load_function_type(&Calibrator_wrapper::default_Load)
, ( bp::arg("path") ) );

}
{ //::gezi::LoadSave::LoadJson

typedef bool ( ::gezi::LoadSave::*LoadJson_function_type )( ::std::string ) ;
typedef bool ( Calibrator_wrapper::*default_LoadJson_function_type )( ::std::string ) ;

Calibrator_exposer.def(
"LoadJson"
, LoadJson_function_type(&::gezi::LoadSave::LoadJson)
, default_LoadJson_function_type(&Calibrator_wrapper::default_LoadJson)
, ( bp::arg("file") ) );

}
{ //::gezi::LoadSave::LoadText

typedef bool ( ::gezi::LoadSave::*LoadText_function_type )( ::std::string ) ;
typedef bool ( Calibrator_wrapper::*default_LoadText_function_type )( ::std::string ) ;

Calibrator_exposer.def(
"LoadText"
, LoadText_function_type(&::gezi::LoadSave::LoadText)
, default_LoadText_function_type(&Calibrator_wrapper::default_LoadText)
, ( bp::arg("file") ) );

}
{ //::gezi::LoadSave::LoadXml

typedef bool ( ::gezi::LoadSave::*LoadXml_function_type )( ::std::string ) ;
typedef bool ( Calibrator_wrapper::*default_LoadXml_function_type )( ::std::string ) ;

Calibrator_exposer.def(
"LoadXml"
, LoadXml_function_type(&::gezi::LoadSave::LoadXml)
, default_LoadXml_function_type(&Calibrator_wrapper::default_LoadXml)
, ( bp::arg("file") ) );

}
{ //::gezi::LoadSave::Save

typedef void ( ::gezi::LoadSave::*Save_function_type )( ::std::string ) ;
typedef void ( Calibrator_wrapper::*default_Save_function_type )( ::std::string ) ;

Calibrator_exposer.def(
"Save"
, Save_function_type(&::gezi::LoadSave::Save)
, default_Save_function_type(&Calibrator_wrapper::default_Save)
, ( bp::arg("path") ) );

}
{ //::gezi::LoadSave::SaveJson

typedef void ( ::gezi::LoadSave::*SaveJson_function_type )( ::std::string ) ;
typedef void ( Calibrator_wrapper::*default_SaveJson_function_type )( ::std::string ) ;

Calibrator_exposer.def(
"SaveJson"
, SaveJson_function_type(&::gezi::LoadSave::SaveJson)
, default_SaveJson_function_type(&Calibrator_wrapper::default_SaveJson)
, ( bp::arg("file") ) );

}
{ //::gezi::LoadSave::SaveText

typedef void ( ::gezi::LoadSave::*SaveText_function_type )( ::std::string ) ;
typedef void ( Calibrator_wrapper::*default_SaveText_function_type )( ::std::string ) ;

Calibrator_exposer.def(
"SaveText"
, SaveText_function_type(&::gezi::LoadSave::SaveText)
, default_SaveText_function_type(&Calibrator_wrapper::default_SaveText)
, ( bp::arg("file") ) );

}
{ //::gezi::LoadSave::SaveXml

typedef void ( ::gezi::LoadSave::*SaveXml_function_type )( ::std::string ) ;
typedef void ( Calibrator_wrapper::*default_SaveXml_function_type )( ::std::string ) ;

Calibrator_exposer.def(
"SaveXml"
, SaveXml_function_type(&::gezi::LoadSave::SaveXml)
, default_SaveXml_function_type(&Calibrator_wrapper::default_SaveXml)
, ( bp::arg("file") ) );

}
bp::register_ptr_to_python< std::shared_ptr< gezi::Calibrator > >();
bp::implicitly_convertible< std::shared_ptr< gezi::Calibrator >, std::shared_ptr< gezi::LoadSave > >();
bp::implicitly_convertible< std::shared_ptr< gezi::NaiveCalibrator >, std::shared_ptr< gezi::Calibrator > >();
bp::implicitly_convertible< std::shared_ptr< gezi::CalibratorWrapper >, std::shared_ptr< gezi::Calibrator > >();
bp::implicitly_convertible< std::shared_ptr< gezi::PAVCalibrator >, std::shared_ptr< gezi::Calibrator > >();
bp::implicitly_convertible< std::shared_ptr< gezi::SigmoidCalibrator >, std::shared_ptr< gezi::Calibrator > >();
}

bp::class_< gezi::CalibratorFactory >( "CalibratorFactory" )
.def(
"CreateCalibrator"
, (::gezi::CalibratorPtr (*)( ::std::string ))( &::gezi::CalibratorFactory::CreateCalibrator )
, ( bp::arg("name") ) )
.def(
"CreateCalibrator"
, (::gezi::CalibratorPtr (*)( ::std::string,::std::string ))( &::gezi::CalibratorFactory::CreateCalibrator )
, ( bp::arg("name"), bp::arg("path") ) )
.def(
"Load"
, (::gezi::CalibratorPtr (*)( ::std::string ))( &::gezi::CalibratorFactory::Load )
, ( bp::arg("path") ) )
.def(
"Save"
, (void (*)( ::gezi::CalibratorPtr,::std::string ))( &::gezi::CalibratorFactory::Save )
, ( bp::arg("calibrator"), bp::arg("path") ) )
.staticmethod( "CreateCalibrator" )
.staticmethod( "Load" )
.staticmethod( "Save" );

{ //::gezi::CalibratorStore
typedef bp::class_< gezi::CalibratorStore > CalibratorStore_exposer_t;
CalibratorStore_exposer_t CalibratorStore_exposer = CalibratorStore_exposer_t( "CalibratorStore", bp::init< >() );
bp::scope CalibratorStore_scope( CalibratorStore_exposer );
bp::enum_< gezi::CalibratorStore::StoreType>("StoreType")
.value("Replace", gezi::CalibratorStore::StoreType::Replace)
.value("Aggregate", gezi::CalibratorStore::StoreType::Aggregate)
.export_values()
;
bp::class_< gezi::CalibratorStore::Node >( "Node", bp::init< Float, Float, Float >(( bp::arg("target_"), bp::arg("weight_"), bp::arg("score_") )) )
.def(
"Set"
, (void ( ::gezi::CalibratorStore::Node::* )( ::Float,::Float,::Float ) )( &::gezi::CalibratorStore::Node::Set )
, ( bp::arg("target_"), bp::arg("weight_"), bp::arg("score_") ) )
.def( bp::self < bp::self )
.def_readwrite( "score", &gezi::CalibratorStore::Node::score )
.def_readwrite( "target", &gezi::CalibratorStore::Node::target )
.def_readwrite( "weight", &gezi::CalibratorStore::Node::weight );
{ //::gezi::CalibratorStore::Add

typedef void ( ::gezi::CalibratorStore::*Add_function_type )( ::Float,bool,::Float ) ;

CalibratorStore_exposer.def(
"Add"
, Add_function_type( &::gezi::CalibratorStore::Add )
, ( bp::arg("score"), bp::arg("IsPositiveTarget"), bp::arg("weight") ) );

}
{ //::gezi::CalibratorStore::Nodes

typedef ::std::vector< gezi::CalibratorStore::Node > & ( ::gezi::CalibratorStore::*Nodes_function_type )(  ) ;

CalibratorStore_exposer.def(
"Nodes"
, Nodes_function_type( &::gezi::CalibratorStore::Nodes )
, bp::return_internal_reference<>());

}
{ //::gezi::CalibratorStore::RandSeed

typedef int ( *RandSeed_function_type )(  );

CalibratorStore_exposer.def(
"RandSeed"
, RandSeed_function_type( &::gezi::CalibratorStore::RandSeed ) );

}
{ //::gezi::CalibratorStore::Sort

typedef void ( ::gezi::CalibratorStore::*Sort_function_type )(  ) ;

CalibratorStore_exposer.def(
"Sort"
, Sort_function_type( &::gezi::CalibratorStore::Sort ) );

}
CalibratorStore_exposer.staticmethod( "RandSeed" );
}

bp::class_< CalibratorWrapper_wrapper, bp::bases< gezi::Calibrator > >( "CalibratorWrapper" )
.def(
"FinishTraining"
, (void ( ::gezi::CalibratorWrapper::* )(  ) )(&::gezi::CalibratorWrapper::FinishTraining)
, (void ( CalibratorWrapper_wrapper::* )(  ) )(&CalibratorWrapper_wrapper::default_FinishTraining) )
.def(
"ProcessTrainingExample"
, (void ( ::gezi::CalibratorWrapper::* )( ::Float,bool,::Float ) )(&::gezi::CalibratorWrapper::ProcessTrainingExample)
, (void ( CalibratorWrapper_wrapper::* )( ::Float,bool,::Float ) )(&CalibratorWrapper_wrapper::default_ProcessTrainingExample)
, ( bp::arg("output"), bp::arg("clicked"), bp::arg("weight") ) )
.def(
"TrainModel"
, (void ( CalibratorWrapper_wrapper::* )( ::gezi::CalibratorStore & ) )(&CalibratorWrapper_wrapper::TrainModel)
, ( bp::arg("data") ) )
.def(
"CustomLoad"
, (bool ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::CustomLoad)
, (bool ( CalibratorWrapper_wrapper::* )( ::std::string ) )(&CalibratorWrapper_wrapper::default_CustomLoad)
, ( bp::arg("path") ) )
.def(
"CustomSave"
, (void ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::CustomSave)
, (void ( CalibratorWrapper_wrapper::* )( ::std::string ) )(&CalibratorWrapper_wrapper::default_CustomSave)
, ( bp::arg("path") ) )
.def(
"Load"
, (bool ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::Load)
, (bool ( CalibratorWrapper_wrapper::* )( ::std::string ) )(&CalibratorWrapper_wrapper::default_Load)
, ( bp::arg("path") ) )
.def(
"LoadJson"
, (bool ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::LoadJson)
, (bool ( CalibratorWrapper_wrapper::* )( ::std::string ) )(&CalibratorWrapper_wrapper::default_LoadJson)
, ( bp::arg("file") ) )
.def(
"LoadText"
, (bool ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::LoadText)
, (bool ( CalibratorWrapper_wrapper::* )( ::std::string ) )(&CalibratorWrapper_wrapper::default_LoadText)
, ( bp::arg("file") ) )
.def(
"LoadXml"
, (bool ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::LoadXml)
, (bool ( CalibratorWrapper_wrapper::* )( ::std::string ) )(&CalibratorWrapper_wrapper::default_LoadXml)
, ( bp::arg("file") ) )
.def(
"Name"
, (::std::string ( ::gezi::Calibrator::* )(  ) )(&::gezi::Calibrator::Name)
, (::std::string ( CalibratorWrapper_wrapper::* )(  ) )(&CalibratorWrapper_wrapper::default_Name) )
.def(
"PredictProbability"
, (::Float ( ::gezi::Calibrator::* )( ::Float ) )(&::gezi::Calibrator::PredictProbability)
, (::Float ( CalibratorWrapper_wrapper::* )( ::Float ) )(&CalibratorWrapper_wrapper::default_PredictProbability)
, ( bp::arg("output") ) )
.def(
"Save"
, (void ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::Save)
, (void ( CalibratorWrapper_wrapper::* )( ::std::string ) )(&CalibratorWrapper_wrapper::default_Save)
, ( bp::arg("path") ) )
.def(
"SaveJson"
, (void ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::SaveJson)
, (void ( CalibratorWrapper_wrapper::* )( ::std::string ) )(&CalibratorWrapper_wrapper::default_SaveJson)
, ( bp::arg("file") ) )
.def(
"SaveText"
, (void ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::SaveText)
, (void ( CalibratorWrapper_wrapper::* )( ::std::string ) )(&CalibratorWrapper_wrapper::default_SaveText)
, ( bp::arg("file") ) )
.def(
"SaveXml"
, (void ( ::gezi::LoadSave::* )( ::std::string ) )(&::gezi::LoadSave::SaveXml)
, (void ( CalibratorWrapper_wrapper::* )( ::std::string ) )(&CalibratorWrapper_wrapper::default_SaveXml)
, ( bp::arg("file") ) );

{ //::gezi::LogHelper
typedef bp::class_< gezi::LogHelper > LogHelper_exposer_t;
LogHelper_exposer_t LogHelper_exposer = LogHelper_exposer_t( "LogHelper", bp::init< bp::optional< int > >(( bp::arg("log_level")=(int)(16) )) );
bp::scope LogHelper_scope( LogHelper_exposer );
bp::implicitly_convertible< int, gezi::LogHelper >();
LogHelper_exposer.def( bp::init< std::string const &, bp::optional< std::string const & > >(( bp::arg("conf_file"), bp::arg("conf_path")="./conf" )) );
{ //::gezi::LogHelper::set_level

typedef void ( *set_level_function_type )( int );

LogHelper_exposer.def(
"set_level"
, set_level_function_type( &::gezi::LogHelper::set_level )
, ( bp::arg("log_level") ) );

}
LogHelper_exposer.staticmethod( "set_level" );
}

//    bp::class_< gezi::PyHack_Vectors >( "PyHack_Vectors" );

bp::class_< gezi::ThreadLogHelper >( "ThreadLogHelper", bp::init< >() );

{ //::gezi::Vector
typedef bp::class_< gezi::Vector > Vector_exposer_t;
Vector_exposer_t Vector_exposer = Vector_exposer_t( "Vector", bp::init< >() );
bp::scope Vector_scope( Vector_exposer );
VEC_METHOD2(Vector_exposer, gezi::Vector);
Vector_exposer.def( bp::init< gezi::Vector const & >(( bp::arg("arg0") )) );
Vector_exposer.def( bp::init< int >(( bp::arg("length_") )) );
bp::implicitly_convertible< int, gezi::Vector >();
Vector_exposer.def( bp::init< Float, int >(( bp::arg("value_"), bp::arg("length_") )) );
Vector_exposer.def( bp::init< int, Float >(( bp::arg("length_"), bp::arg("value_") )) );
Vector_exposer.def( bp::init< std::map< int, double > const & >(( bp::arg("m") )) );
bp::implicitly_convertible< std::map< int, double > const &, gezi::Vector >();
Vector_exposer.def( bp::init< int, ivec &, std::vector< double > & >(( bp::arg("length_"), bp::arg("indices_"), bp::arg("values_") )) );
Vector_exposer.def( bp::init< ivec &, std::vector< double > &, bp::optional< int > >(( bp::arg("indices_"), bp::arg("values_"), bp::arg("length_")=(int)(1024000) )) );
Vector_exposer.def( bp::init< std::vector< double > & >(( bp::arg("values_") )) );
bp::implicitly_convertible< std::vector< double > &, gezi::Vector >();
Vector_exposer.def( bp::init< std::string, bp::optional< int, int, std::string, bool > >(( bp::arg("input"), bp::arg("startIndex")=(int)(0), bp::arg("length_")=(int)(1024000), bp::arg("sep")=",\011 ", bp::arg("indexOnly")=(bool)(false) )) );
Vector_exposer.def( bp::init< __gnu_cxx::__normal_iterator< double*, std::vector< double > >, __gnu_cxx::__normal_iterator< double*, std::vector< double > > >(( bp::arg("first"), bp::arg("end") )) );
{ //::gezi::Vector::Add

typedef void ( ::gezi::Vector::*Add_function_type )( ::Float ) ;

Vector_exposer.def(
"Add"
, Add_function_type( &::gezi::Vector::Add )
, ( bp::arg("value") ) );

}
{ //::gezi::Vector::Add

typedef void ( ::gezi::Vector::*Add_function_type )( int,::Float ) ;

Vector_exposer.def(
"Add"
, Add_function_type( &::gezi::Vector::Add )
, ( bp::arg("index"), bp::arg("value") ) );

}
{ //::gezi::Vector::Add

typedef void ( ::gezi::Vector::*Add_function_type )( ::gezi::Vector const & ) ;

Vector_exposer.def(
"Add"
, Add_function_type( &::gezi::Vector::Add )
, ( bp::arg("other") ) );

}
{ //::gezi::Vector::AddMap

typedef void ( ::gezi::Vector::*AddMap_function_type )( ::std::map< int, double > const & ) ;

Vector_exposer.def(
"AddMap"
, AddMap_function_type( &::gezi::Vector::AddMap )
, ( bp::arg("m") ) );

}
{ //::gezi::Vector::AllStr

typedef ::std::string ( ::gezi::Vector::*AllStr_function_type )( ::std::string ) const;

Vector_exposer.def(
"AllStr"
, AllStr_function_type( &::gezi::Vector::AllStr )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::Vector::CheckInvariants

typedef void ( ::gezi::Vector::*CheckInvariants_function_type )(  ) ;

Vector_exposer.def(
"CheckInvariants"
, CheckInvariants_function_type( &::gezi::Vector::CheckInvariants ) );

}
{ //::gezi::Vector::Clear

typedef void ( ::gezi::Vector::*Clear_function_type )(  ) ;

Vector_exposer.def(
"Clear"
, Clear_function_type( &::gezi::Vector::Clear ) );

}
{ //::gezi::Vector::Count

typedef int ( ::gezi::Vector::*Count_function_type )(  ) const;

Vector_exposer.def(
"Count"
, Count_function_type( &::gezi::Vector::Count ) );

}
{ //::gezi::Vector::DenseStr

typedef ::std::string ( ::gezi::Vector::*DenseStr_function_type )( ::std::string ) const;

Vector_exposer.def(
"DenseStr"
, DenseStr_function_type( &::gezi::Vector::DenseStr )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::Vector::Densify

typedef void ( ::gezi::Vector::*Densify_function_type )( ::Float ) ;

Vector_exposer.def(
"Densify"
, Densify_function_type( &::gezi::Vector::Densify )
, ( bp::arg("maxSparsity") ) );

}
{ //::gezi::Vector::Densify

typedef void ( ::gezi::Vector::*Densify_function_type )(  ) ;

Vector_exposer.def(
"Densify"
, Densify_function_type( &::gezi::Vector::Densify ) );

}
{ //::gezi::Vector::Empty

typedef bool ( ::gezi::Vector::*Empty_function_type )(  ) const;

Vector_exposer.def(
"Empty"
, Empty_function_type( &::gezi::Vector::Empty ) );

}
{ //::gezi::Vector::ForceDense

typedef void ( ::gezi::Vector::*ForceDense_function_type )(  ) ;

Vector_exposer.def(
"ForceDense"
, ForceDense_function_type( &::gezi::Vector::ForceDense ) );

}
{ //::gezi::Vector::ForceSparse

typedef void ( ::gezi::Vector::*ForceSparse_function_type )(  ) ;

Vector_exposer.def(
"ForceSparse"
, ForceSparse_function_type( &::gezi::Vector::ForceSparse ) );

}
{ //::gezi::Vector::Index

typedef int ( ::gezi::Vector::*Index_function_type )( int ) const;

Vector_exposer.def(
"Index"
, Index_function_type( &::gezi::Vector::Index )
, ( bp::arg("index") ) );

}
{ //::gezi::Vector::Indices

typedef ::ivec const & ( ::gezi::Vector::*Indices_function_type )(  ) const;

Vector_exposer.def(
"Indices"
, Indices_function_type( &::gezi::Vector::Indices )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::Vector::Indices

typedef ::ivec & ( ::gezi::Vector::*Indices_function_type )(  ) ;

Vector_exposer.def(
"Indices"
, Indices_function_type( &::gezi::Vector::Indices )
, bp::return_internal_reference<>());

}
{ //::gezi::Vector::Init

typedef void ( ::gezi::Vector::*Init_function_type )( ::std::string,int,int,::std::string,bool ) ;

Vector_exposer.def(
"Init"
, Init_function_type( &::gezi::Vector::Init )
, ( bp::arg("input"), bp::arg("startIndex")=(int)(0), bp::arg("length_")=(int)(0), bp::arg("sep")=",\011 ", bp::arg("indexOnly")=(bool)(false) ) );

}
{ //::gezi::Vector::Init

typedef void ( ::gezi::Vector::*Init_function_type )( int,::std::vector< int > &,::std::vector< double > & ) ;

Vector_exposer.def(
"Init"
, Init_function_type( &::gezi::Vector::Init )
, ( bp::arg("length_"), bp::arg("indices_"), bp::arg("values_") ) );

}
{ //::gezi::Vector::Init

typedef void ( ::gezi::Vector::*Init_function_type )( ::std::vector< double > & ) ;

Vector_exposer.def(
"Init"
, Init_function_type( &::gezi::Vector::Init )
, ( bp::arg("values_") ) );

}
{ //::gezi::Vector::IsDense

typedef bool ( ::gezi::Vector::*IsDense_function_type )(  ) const;

Vector_exposer.def(
"IsDense"
, IsDense_function_type( &::gezi::Vector::IsDense ) );

}
{ //::gezi::Vector::IsSparse

typedef bool ( ::gezi::Vector::*IsSparse_function_type )(  ) const;

Vector_exposer.def(
"IsSparse"
, IsSparse_function_type( &::gezi::Vector::IsSparse ) );

}
{ //::gezi::Vector::Length

typedef int ( ::gezi::Vector::*Length_function_type )(  ) const;

Vector_exposer.def(
"Length"
, Length_function_type( &::gezi::Vector::Length ) );

}
{ //::gezi::Vector::MakeDense

typedef void ( ::gezi::Vector::*MakeDense_function_type )(  ) ;

Vector_exposer.def(
"MakeDense"
, MakeDense_function_type( &::gezi::Vector::MakeDense ) );

}
{ //::gezi::Vector::MakeSparse

typedef void ( ::gezi::Vector::*MakeSparse_function_type )(  ) ;

Vector_exposer.def(
"MakeSparse"
, MakeSparse_function_type( &::gezi::Vector::MakeSparse ) );

}
{ //::gezi::Vector::Norm

typedef ::Float ( ::gezi::Vector::*Norm_function_type )(  ) const;

Vector_exposer.def(
"Norm"
, Norm_function_type( &::gezi::Vector::Norm ) );

}
{ //::gezi::Vector::NumNonZeros

typedef int ( ::gezi::Vector::*NumNonZeros_function_type )(  ) ;

Vector_exposer.def(
"NumNonZeros"
, NumNonZeros_function_type( &::gezi::Vector::NumNonZeros ) );

}
{ //::gezi::Vector::PrepareDense

typedef void ( ::gezi::Vector::*PrepareDense_function_type )(  ) ;

Vector_exposer.def(
"PrepareDense"
, PrepareDense_function_type( &::gezi::Vector::PrepareDense ) );

}
{ //::gezi::Vector::Resize

typedef void ( ::gezi::Vector::*Resize_function_type )( int,::Float ) ;

Vector_exposer.def(
"Resize"
, Resize_function_type( &::gezi::Vector::Resize )
, ( bp::arg("length_"), bp::arg("value_")=0 ) );

}
{ //::gezi::Vector::ScaleBy

typedef void ( ::gezi::Vector::*ScaleBy_function_type )( ::Float ) ;

Vector_exposer.def(
"ScaleBy"
, ScaleBy_function_type( &::gezi::Vector::ScaleBy )
, ( bp::arg("d") ) );

}
{ //::gezi::Vector::SetIndex

typedef void ( ::gezi::Vector::*SetIndex_function_type )( int,int ) ;

Vector_exposer.def(
"SetIndex"
, SetIndex_function_type( &::gezi::Vector::SetIndex )
, ( bp::arg("index"), bp::arg("indexValue") ) );

}
{ //::gezi::Vector::SetLength

typedef void ( ::gezi::Vector::*SetLength_function_type )( int ) ;

Vector_exposer.def(
"SetLength"
, SetLength_function_type( &::gezi::Vector::SetLength )
, ( bp::arg("length_") ) );

}
{ //::gezi::Vector::SetValue

typedef void ( ::gezi::Vector::*SetValue_function_type )( int,::Float ) ;

Vector_exposer.def(
"SetValue"
, SetValue_function_type( &::gezi::Vector::SetValue )
, ( bp::arg("index"), bp::arg("value") ) );

}
{ //::gezi::Vector::Sparsify

typedef void ( ::gezi::Vector::*Sparsify_function_type )( ::Float ) ;

Vector_exposer.def(
"Sparsify"
, Sparsify_function_type( &::gezi::Vector::Sparsify )
, ( bp::arg("maxSparsity") ) );

}
{ //::gezi::Vector::Sparsify

typedef void ( ::gezi::Vector::*Sparsify_function_type )(  ) ;

Vector_exposer.def(
"Sparsify"
, Sparsify_function_type( &::gezi::Vector::Sparsify ) );

}
{ //::gezi::Vector::SquaredNorm

typedef ::Float ( ::gezi::Vector::*SquaredNorm_function_type )(  ) const;

Vector_exposer.def(
"SquaredNorm"
, SquaredNorm_function_type( &::gezi::Vector::SquaredNorm ) );

}
{ //::gezi::Vector::Str

typedef ::std::string ( ::gezi::Vector::*Str_function_type )( ::std::string ) const;

Vector_exposer.def(
"Str"
, Str_function_type( &::gezi::Vector::Str )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::Vector::Subtract

typedef void ( ::gezi::Vector::*Subtract_function_type )( ::gezi::Vector const & ) ;

Vector_exposer.def(
"Subtract"
, Subtract_function_type( &::gezi::Vector::Subtract )
, ( bp::arg("other") ) );

}
{ //::gezi::Vector::Swap

typedef void ( ::gezi::Vector::*Swap_function_type )( ::gezi::Vector & ) ;

Vector_exposer.def(
"Swap"
, Swap_function_type( &::gezi::Vector::Swap )
, ( bp::arg("other") ) );

}
{ //::gezi::Vector::ToDense

typedef void ( ::gezi::Vector::*ToDense_function_type )( ::std::vector< double > & ) ;

Vector_exposer.def(
"ToDense"
, ToDense_function_type( &::gezi::Vector::ToDense )
, ( bp::arg("values_") ) );

}
{ //::gezi::Vector::ToDense

typedef void ( ::gezi::Vector::*ToDense_function_type )(  ) ;

Vector_exposer.def(
"ToDense"
, ToDense_function_type( &::gezi::Vector::ToDense ) );

}
{ //::gezi::Vector::ToSparse

typedef void ( ::gezi::Vector::*ToSparse_function_type )(  ) ;

Vector_exposer.def(
"ToSparse"
, ToSparse_function_type( &::gezi::Vector::ToSparse ) );

}
{ //::gezi::Vector::Value

typedef ::Float ( ::gezi::Vector::*Value_function_type )( int ) const;

Vector_exposer.def(
"Value"
, Value_function_type( &::gezi::Vector::Value )
, ( bp::arg("index") ) );

}
{ //::gezi::Vector::Values

typedef ::std::vector< double > const & ( ::gezi::Vector::*Values_function_type )(  ) const;

Vector_exposer.def(
"Values"
, Values_function_type( &::gezi::Vector::Values )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::Vector::Values

typedef ::std::vector< double > & ( ::gezi::Vector::*Values_function_type )(  ) ;

Vector_exposer.def(
"Values"
, Values_function_type( &::gezi::Vector::Values )
, bp::return_internal_reference<>());

}
{ //::gezi::Vector::back

typedef ::Float ( ::gezi::Vector::*back_function_type )(  ) ;

Vector_exposer.def(
"back"
, back_function_type( &::gezi::Vector::back ) );

}
{ //::gezi::Vector::clear

typedef void ( ::gezi::Vector::*clear_function_type )(  ) ;

Vector_exposer.def(
"clear"
, clear_function_type( &::gezi::Vector::clear ) );

}
{ //::gezi::Vector::dot

typedef ::Float ( ::gezi::Vector::*dot_function_type )( ::gezi::Vector const & ) const;

Vector_exposer.def(
"dot"
, dot_function_type( &::gezi::Vector::dot )
, ( bp::arg("other") ) );

}
{ //::gezi::Vector::empty

typedef bool ( ::gezi::Vector::*empty_function_type )(  ) const;

Vector_exposer.def(
"empty"
, empty_function_type( &::gezi::Vector::empty ) );

}
{ //::gezi::Vector::erase

typedef void ( ::gezi::Vector::*erase_function_type )( ::__gnu_cxx::__normal_iterator< double*, std::vector< double > > ) ;

Vector_exposer.def(
"erase"
, erase_function_type( &::gezi::Vector::erase )
, ( bp::arg("pos") ) );

}
{ //::gezi::Vector::erase

typedef void ( ::gezi::Vector::*erase_function_type )( ::__gnu_cxx::__normal_iterator< double*, std::vector< double > >,::__gnu_cxx::__normal_iterator< double*, std::vector< double > > ) ;

Vector_exposer.def(
"erase"
, erase_function_type( &::gezi::Vector::erase )
, ( bp::arg("first"), bp::arg("last") ) );

}
{ //::gezi::Vector::front

typedef ::Float ( ::gezi::Vector::*front_function_type )(  ) ;

Vector_exposer.def(
"front"
, front_function_type( &::gezi::Vector::front ) );

}
{ //::gezi::Vector::insert

typedef ::__gnu_cxx::__normal_iterator< double*, std::vector< double > > ( ::gezi::Vector::*insert_function_type )( ::__gnu_cxx::__normal_iterator< double*, std::vector< double > >,::Float const & ) ;

Vector_exposer.def(
"insert"
, insert_function_type( &::gezi::Vector::insert )
, ( bp::arg("position"), bp::arg("val") ) );

}
{ //::gezi::Vector::operator()

typedef ::gezi::Vector & ( ::gezi::Vector::*__call___function_type )( int,::Float ) ;

Vector_exposer.def(
"__call__"
, __call___function_type( &::gezi::Vector::operator() )
, ( bp::arg("index"), bp::arg("value") )
, bp::return_internal_reference<>());

}
Vector_exposer.def( bp::self *= bp::other< Float >() );
Vector_exposer.def( bp::self += bp::self );
Vector_exposer.def( bp::self -= bp::self );
Vector_exposer.def( bp::self /= bp::other< Float >() );
{ //::gezi::Vector::operator=

typedef ::gezi::Vector & ( ::gezi::Vector::*assign_function_type )( ::gezi::Vector const & ) ;

Vector_exposer.def(
"assign"
, assign_function_type( &::gezi::Vector::operator= )
, ( bp::arg("arg0") )
, bp::return_self< >() );

}
Vector_exposer.def( bp::self == bp::self );
{ //::gezi::Vector::operator[]

typedef ::Float ( ::gezi::Vector::*__getitem___function_type )( int ) const;

Vector_exposer.def(
"__getitem__"
, __getitem___function_type( &::gezi::Vector::operator[] )
, ( bp::arg("index") ) );

}
{ //::gezi::Vector::push_back

typedef void ( ::gezi::Vector::*push_back_function_type )( ::Float ) ;

Vector_exposer.def(
"push_back"
, push_back_function_type( &::gezi::Vector::push_back )
, ( bp::arg("item") ) );

}
{ //::gezi::Vector::resize

typedef void ( ::gezi::Vector::*resize_function_type )( int,::Float ) ;

Vector_exposer.def(
"resize"
, resize_function_type( &::gezi::Vector::resize )
, ( bp::arg("length_"), bp::arg("value_")=0 ) );

}
{ //::gezi::Vector::size

typedef ::size_t ( ::gezi::Vector::*size_function_type )(  ) const;

Vector_exposer.def(
"size"
, size_function_type( &::gezi::Vector::size ) );

}
{ //::gezi::Vector::str

typedef ::std::string ( ::gezi::Vector::*str_function_type )( ::std::string ) const;

Vector_exposer.def(
"str"
, str_function_type( &::gezi::Vector::str )
, ( bp::arg("sep")="," ) );

}
Vector_exposer.def_readwrite( "indices", &gezi::Vector::indices );
Vector_exposer.def_readwrite( "keepDense", &gezi::Vector::keepDense );
Vector_exposer.def_readwrite( "keepSparse", &gezi::Vector::keepSparse );
Vector_exposer.def_readwrite( "normalized", &gezi::Vector::normalized );
Vector_exposer.def_readwrite( "numNonZeros", &gezi::Vector::numNonZeros );
Vector_exposer.def_readwrite( "sparsityRatio", &gezi::Vector::sparsityRatio );
Vector_exposer.def_readwrite( "values", &gezi::Vector::values );
}
}
