#define private public
#define protected public
#include "python_util.h"
// This file has been generated by Py++.

#include "boost/python.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "boost/python/suite/indexing/map_indexing_suite.hpp"

#include "common_util.h"

#include "log_util.h"

#include "Prediction/Normalization/Normalizer.h"

#include "Prediction/Normalization/NormalizerFactory.h"

#include "Numeric/Vector/Vector.h"

namespace bp = boost::python;

struct Normalizer_wrapper : gezi::Normalizer, bp::wrapper< gezi::Normalizer > {

Normalizer_wrapper(gezi::Normalizer const & arg )
: gezi::Normalizer( arg )
, bp::wrapper< gezi::Normalizer >(){
// copy constructor

}

Normalizer_wrapper( )
: gezi::Normalizer( )
, bp::wrapper< gezi::Normalizer >(){
// null constructor

}

virtual void Begin(  ) {
if( bp::override func_Begin = this->get_override( "Begin" ) )
func_Begin(  );
else
this->gezi::Normalizer::Begin(  );
}


void default_Begin(  ) {
gezi::Normalizer::Begin( );
}

virtual void Finish(  ) {
if( bp::override func_Finish = this->get_override( "Finish" ) )
func_Finish(  );
else
this->gezi::Normalizer::Finish(  );
}


void default_Finish(  ) {
gezi::Normalizer::Finish( );
}

virtual ::std::string Name(  ) {
if( bp::override func_Name = this->get_override( "Name" ) )
return func_Name(  );
else
return this->gezi::Normalizer::Name(  );
}


::std::string default_Name(  ) {
return gezi::Normalizer::Name( );
}

virtual void Process( ::gezi::Vector const & vec ) {
if( bp::override func_Process = this->get_override( "Process" ) )
func_Process( boost::ref(vec) );
else
this->gezi::Normalizer::Process( boost::ref(vec) );
}


void default_Process( ::gezi::Vector const & vec ) {
gezi::Normalizer::Process( boost::ref(vec) );
}

};

BOOST_PYTHON_MODULE(libnormalizer){
DEF_VEC(ivec);
DEF_VEC(dvec);
DEF_VEC(uvec);
DEF_VEC(svec);
DEF_VEC(ulvec);
DEF_MAP(id_map);
DEF_MAP(sd_map);
DEF_MAP(si_map);
DEF_MAP(ss_map);
DEF_PAIR(ii_pair);
DEF_PAIR(si_pair);
DEF_PAIR(wsi_pair);
DEF_VEC(si_pair_vec);
DEF_VEC(wsi_pair_vec);
DEF_SET(iset);
DEF_SET(lset);
DEF_SET(ulset);

{ //::std::vector< int >
typedef bp::class_< std::vector< int > > ivec_exposer_t;
ivec_exposer_t ivec_exposer = ivec_exposer_t( "ivec" );
bp::scope ivec_scope( ivec_exposer );
ivec_exposer.def( bp::vector_indexing_suite< ::std::vector< int >, true >() )
VEC_METHOD(::std::vector< int >);
}

{ //::std::vector< double >
typedef bp::class_< std::vector< double > > vector_less__double__greater__exposer_t;
vector_less__double__greater__exposer_t vector_less__double__greater__exposer = vector_less__double__greater__exposer_t( "vector_less__double__greater_" );
bp::scope vector_less__double__greater__scope( vector_less__double__greater__exposer );
vector_less__double__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< double >, true >() )
VEC_METHOD(::std::vector< double >);
}

bp::class_< std::map< int, double > >("map_less__int_comma__double__greater_")
.def( bp::map_indexing_suite< ::std::map< int, double >, true >() )
MAP_METHOD(::std::map< int COMMA  double >);

{ //::gezi::LogHelper
typedef bp::class_< gezi::LogHelper > LogHelper_exposer_t;
LogHelper_exposer_t LogHelper_exposer = LogHelper_exposer_t( "LogHelper", bp::init< bp::optional< int > >(( bp::arg("log_level")=(int)(16) )) );
bp::scope LogHelper_scope( LogHelper_exposer );
bp::implicitly_convertible< int, gezi::LogHelper >();
LogHelper_exposer.def( bp::init< std::string const &, bp::optional< std::string const & > >(( bp::arg("conf_file"), bp::arg("conf_path")="./conf" )) );
{ //::gezi::LogHelper::set_level

typedef void ( *set_level_function_type )( int );

LogHelper_exposer.def(
"set_level"
, set_level_function_type( &::gezi::LogHelper::set_level )
, ( bp::arg("log_level") ) );

}
LogHelper_exposer.staticmethod( "set_level" );
}

{ //::gezi::Normalizer
typedef bp::class_< Normalizer_wrapper > Normalizer_exposer_t;
Normalizer_exposer_t Normalizer_exposer = Normalizer_exposer_t( "Normalizer", bp::init< >() );
bp::scope Normalizer_scope( Normalizer_exposer );
bp::enum_< gezi::Normalizer::NormType>("NormType")
.value("Affine", gezi::Normalizer::NormType::Affine)
.value("Bin", gezi::Normalizer::NormType::Bin)
.export_values()
;
{ //::gezi::Normalizer::Begin

typedef void ( ::gezi::Normalizer::*Begin_function_type )(  ) ;
typedef void ( Normalizer_wrapper::*default_Begin_function_type )(  ) ;

Normalizer_exposer.def(
"Begin"
, Begin_function_type(&::gezi::Normalizer::Begin)
, default_Begin_function_type(&Normalizer_wrapper::default_Begin) );

}
{ //::gezi::Normalizer::Finish

typedef void ( ::gezi::Normalizer::*Finish_function_type )(  ) ;
typedef void ( Normalizer_wrapper::*default_Finish_function_type )(  ) ;

Normalizer_exposer.def(
"Finish"
, Finish_function_type(&::gezi::Normalizer::Finish)
, default_Finish_function_type(&Normalizer_wrapper::default_Finish) );

}
{ //::gezi::Normalizer::Name

typedef ::std::string ( ::gezi::Normalizer::*Name_function_type )(  ) ;
typedef ::std::string ( Normalizer_wrapper::*default_Name_function_type )(  ) ;

Normalizer_exposer.def(
"Name"
, Name_function_type(&::gezi::Normalizer::Name)
, default_Name_function_type(&Normalizer_wrapper::default_Name) );

}
{ //::gezi::Normalizer::Normalize

typedef void ( ::gezi::Normalizer::*Normalize_function_type )( ::gezi::Vector & ) ;

Normalizer_exposer.def(
"Normalize"
, Normalize_function_type( &::gezi::Normalizer::Normalize )
, ( bp::arg("vec") ) );

}
{ //::gezi::Normalizer::Normalize

typedef void ( ::gezi::Normalizer::*Normalize_function_type )( ::gezi::Instance & ) ;

Normalizer_exposer.def(
"Normalize"
, Normalize_function_type( &::gezi::Normalizer::Normalize )
, ( bp::arg("instance") ) );

}
{ //::gezi::Normalizer::Normalize

typedef void ( ::gezi::Normalizer::*Normalize_function_type )( ::gezi::InstancePtr ) ;

Normalizer_exposer.def(
"Normalize"
, Normalize_function_type( &::gezi::Normalizer::Normalize )
, ( bp::arg("instance") ) );

}
{ //::gezi::Normalizer::Normalize

typedef void ( ::gezi::Normalizer::*Normalize_function_type )( ::gezi::Instances & ) ;

Normalizer_exposer.def(
"Normalize"
, Normalize_function_type( &::gezi::Normalizer::Normalize )
, ( bp::arg("instances") ) );

}
{ //::gezi::Normalizer::NormalizeCopy

typedef ::gezi::Vector ( ::gezi::Normalizer::*NormalizeCopy_function_type )( ::gezi::Vector const & ) ;

Normalizer_exposer.def(
"NormalizeCopy"
, NormalizeCopy_function_type( &::gezi::Normalizer::NormalizeCopy )
, ( bp::arg("vec") ) );

}
{ //::gezi::Normalizer::NormalizeCopy

typedef ::gezi::Instance ( ::gezi::Normalizer::*NormalizeCopy_function_type )( ::gezi::Instance const & ) ;

Normalizer_exposer.def(
"NormalizeCopy"
, NormalizeCopy_function_type( &::gezi::Normalizer::NormalizeCopy )
, ( bp::arg("instance") ) );

}
{ //::gezi::Normalizer::NormalizeCopy

typedef ::gezi::InstancePtr ( ::gezi::Normalizer::*NormalizeCopy_function_type )( ::gezi::InstancePtr ) ;

Normalizer_exposer.def(
"NormalizeCopy"
, NormalizeCopy_function_type( &::gezi::Normalizer::NormalizeCopy )
, ( bp::arg("instance") ) );

}
{ //::gezi::Normalizer::NormalizeCopy

typedef ::gezi::Instances ( ::gezi::Normalizer::*NormalizeCopy_function_type )( ::gezi::Instances const & ) ;

Normalizer_exposer.def(
"NormalizeCopy"
, NormalizeCopy_function_type( &::gezi::Normalizer::NormalizeCopy )
, ( bp::arg("instances") ) );

}
{ //::gezi::Normalizer::ParseArgs

typedef void ( ::gezi::Normalizer::*ParseArgs_function_type )(  ) ;

Normalizer_exposer.def(
"ParseArgs"
, ParseArgs_function_type( &::gezi::Normalizer::ParseArgs ) );

}
{ //::gezi::Normalizer::Prepare

typedef void ( ::gezi::Normalizer::*Prepare_function_type )( ::gezi::Instances const & ) ;

Normalizer_exposer.def(
"Prepare"
, Prepare_function_type( &::gezi::Normalizer::Prepare )
, ( bp::arg("instances") ) );

}
{ //::gezi::Normalizer::Process

typedef void ( ::gezi::Normalizer::*Process_function_type )( ::gezi::Vector const & ) ;
typedef void ( Normalizer_wrapper::*default_Process_function_type )( ::gezi::Vector const & ) ;

Normalizer_exposer.def(
"Process"
, Process_function_type(&::gezi::Normalizer::Process)
, default_Process_function_type(&Normalizer_wrapper::default_Process)
, ( bp::arg("vec") ) );

}
{ //::gezi::Normalizer::RunNormalize

typedef void ( ::gezi::Normalizer::*RunNormalize_function_type )( ::gezi::Instances & ) ;

Normalizer_exposer.def(
"RunNormalize"
, RunNormalize_function_type( &::gezi::Normalizer::RunNormalize )
, ( bp::arg("instances") ) );

}
{ //::gezi::Normalizer::RunNormalizeCopy

typedef ::gezi::Instances ( ::gezi::Normalizer::*RunNormalizeCopy_function_type )( ::gezi::Instances const & ) ;

Normalizer_exposer.def(
"RunNormalizeCopy"
, RunNormalizeCopy_function_type( &::gezi::Normalizer::RunNormalizeCopy )
, ( bp::arg("instances") ) );

}
{ //::gezi::Normalizer::SetTrunct

typedef void ( ::gezi::Normalizer::*SetTrunct_function_type )( bool ) ;

Normalizer_exposer.def(
"SetTrunct"
, SetTrunct_function_type( &::gezi::Normalizer::SetTrunct )
, ( bp::arg("trunct") ) );

}
{ //::gezi::Normalizer::Trunct

typedef bool ( ::gezi::Normalizer::*Trunct_function_type )(  ) const;

Normalizer_exposer.def(
"Trunct"
, Trunct_function_type( &::gezi::Normalizer::Trunct ) );

}
bp::register_ptr_to_python< std::shared_ptr< gezi::Normalizer > >();
bp::implicitly_convertible< std::shared_ptr< gezi::Normalizer >, std::shared_ptr< gezi::LoadSave > >();
bp::implicitly_convertible< std::shared_ptr< gezi::BinNormalizer >, std::shared_ptr< gezi::Normalizer > >();
bp::implicitly_convertible< std::shared_ptr< gezi::AffineNormalizer >, std::shared_ptr< gezi::Normalizer > >();
bp::implicitly_convertible< std::shared_ptr< gezi::GaussianNormalizer >, std::shared_ptr< gezi::Normalizer > >();
bp::implicitly_convertible< std::shared_ptr< gezi::MinMaxNormalizer >, std::shared_ptr< gezi::Normalizer > >();
}

bp::class_< gezi::NormalizerFactory >( "NormalizerFactory" )
.def(
"CreateNormalizer"
, (::gezi::NormalizerPtr (*)( ::std::string ))( &::gezi::NormalizerFactory::CreateNormalizer )
, ( bp::arg("name") ) )
.def(
"CreateNormalizer"
, (::gezi::NormalizerPtr (*)( ::std::string,::std::string ))( &::gezi::NormalizerFactory::CreateNormalizer )
, ( bp::arg("name"), bp::arg("path") ) )
.def(
"Load"
, (::gezi::NormalizerPtr (*)( ::std::string ))( &::gezi::NormalizerFactory::Load )
, ( bp::arg("path") ) )
.def(
"Save"
, (void (*)( ::gezi::NormalizerPtr,::std::string ))( &::gezi::NormalizerFactory::Save )
, ( bp::arg("normalizer"), bp::arg("path") ) )
.staticmethod( "CreateNormalizer" )
.staticmethod( "Load" )
.staticmethod( "Save" );

bp::class_< gezi::ThreadLogHelper >( "ThreadLogHelper", bp::init< >() );

{ //::gezi::Vector
typedef bp::class_< gezi::Vector > Vector_exposer_t;
Vector_exposer_t Vector_exposer = Vector_exposer_t( "Vector", bp::init< >() );
bp::scope Vector_scope( Vector_exposer );
VEC_METHOD2(Vector_exposer, gezi::Vector);
Vector_exposer.def( bp::init< gezi::Vector const & >(( bp::arg("arg0") )) );
Vector_exposer.def( bp::init< int >(( bp::arg("length_") )) );
bp::implicitly_convertible< int, gezi::Vector >();
Vector_exposer.def( bp::init< Float, int >(( bp::arg("value_"), bp::arg("length_") )) );
Vector_exposer.def( bp::init< int, Float >(( bp::arg("length_"), bp::arg("value_") )) );
Vector_exposer.def( bp::init< std::map< int, double > const & >(( bp::arg("m") )) );
bp::implicitly_convertible< std::map< int, double > const &, gezi::Vector >();
Vector_exposer.def( bp::init< int, ivec &, std::vector< double > & >(( bp::arg("length_"), bp::arg("indices_"), bp::arg("values_") )) );
Vector_exposer.def( bp::init< ivec &, std::vector< double > &, bp::optional< int > >(( bp::arg("indices_"), bp::arg("values_"), bp::arg("length_")=(int)(1024000) )) );
Vector_exposer.def( bp::init< std::vector< double > & >(( bp::arg("values_") )) );
bp::implicitly_convertible< std::vector< double > &, gezi::Vector >();
Vector_exposer.def( bp::init< std::string, bp::optional< int, int, std::string > >(( bp::arg("input"), bp::arg("startIndex")=(int)(0), bp::arg("length_")=(int)(1024000), bp::arg("sep")=",\011 " )) );
Vector_exposer.def( bp::init< __gnu_cxx::__normal_iterator< double*, std::vector< double > >, __gnu_cxx::__normal_iterator< double*, std::vector< double > > >(( bp::arg("first"), bp::arg("end") )) );
{ //::gezi::Vector::Add

typedef void ( ::gezi::Vector::*Add_function_type )( ::Float ) ;

Vector_exposer.def(
"Add"
, Add_function_type( &::gezi::Vector::Add )
, ( bp::arg("value") ) );

}
{ //::gezi::Vector::Add

typedef void ( ::gezi::Vector::*Add_function_type )( int,::Float ) ;

Vector_exposer.def(
"Add"
, Add_function_type( &::gezi::Vector::Add )
, ( bp::arg("index"), bp::arg("value") ) );

}
{ //::gezi::Vector::Add

typedef void ( ::gezi::Vector::*Add_function_type )( ::gezi::Vector const & ) ;

Vector_exposer.def(
"Add"
, Add_function_type( &::gezi::Vector::Add )
, ( bp::arg("other") ) );

}
{ //::gezi::Vector::AddMap

typedef void ( ::gezi::Vector::*AddMap_function_type )( ::std::map< int, double > const & ) ;

Vector_exposer.def(
"AddMap"
, AddMap_function_type( &::gezi::Vector::AddMap )
, ( bp::arg("m") ) );

}
{ //::gezi::Vector::AllStr

typedef ::std::string ( ::gezi::Vector::*AllStr_function_type )( ::std::string ) const;

Vector_exposer.def(
"AllStr"
, AllStr_function_type( &::gezi::Vector::AllStr )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::Vector::CheckInvariants

typedef void ( ::gezi::Vector::*CheckInvariants_function_type )(  ) ;

Vector_exposer.def(
"CheckInvariants"
, CheckInvariants_function_type( &::gezi::Vector::CheckInvariants ) );

}
{ //::gezi::Vector::Clear

typedef void ( ::gezi::Vector::*Clear_function_type )(  ) ;

Vector_exposer.def(
"Clear"
, Clear_function_type( &::gezi::Vector::Clear ) );

}
{ //::gezi::Vector::Count

typedef int ( ::gezi::Vector::*Count_function_type )(  ) const;

Vector_exposer.def(
"Count"
, Count_function_type( &::gezi::Vector::Count ) );

}
{ //::gezi::Vector::DenseStr

typedef ::std::string ( ::gezi::Vector::*DenseStr_function_type )( ::std::string ) const;

Vector_exposer.def(
"DenseStr"
, DenseStr_function_type( &::gezi::Vector::DenseStr )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::Vector::Densify

typedef void ( ::gezi::Vector::*Densify_function_type )( ::Float ) ;

Vector_exposer.def(
"Densify"
, Densify_function_type( &::gezi::Vector::Densify )
, ( bp::arg("maxSparsity") ) );

}
{ //::gezi::Vector::Densify

typedef void ( ::gezi::Vector::*Densify_function_type )(  ) ;

Vector_exposer.def(
"Densify"
, Densify_function_type( &::gezi::Vector::Densify ) );

}
{ //::gezi::Vector::Empty

typedef bool ( ::gezi::Vector::*Empty_function_type )(  ) const;

Vector_exposer.def(
"Empty"
, Empty_function_type( &::gezi::Vector::Empty ) );

}
{ //::gezi::Vector::ForceDense

typedef void ( ::gezi::Vector::*ForceDense_function_type )(  ) ;

Vector_exposer.def(
"ForceDense"
, ForceDense_function_type( &::gezi::Vector::ForceDense ) );

}
{ //::gezi::Vector::ForceSparse

typedef void ( ::gezi::Vector::*ForceSparse_function_type )(  ) ;

Vector_exposer.def(
"ForceSparse"
, ForceSparse_function_type( &::gezi::Vector::ForceSparse ) );

}
{ //::gezi::Vector::Index

typedef int ( ::gezi::Vector::*Index_function_type )( int ) const;

Vector_exposer.def(
"Index"
, Index_function_type( &::gezi::Vector::Index )
, ( bp::arg("index") ) );

}
{ //::gezi::Vector::Indices

typedef ::ivec const & ( ::gezi::Vector::*Indices_function_type )(  ) const;

Vector_exposer.def(
"Indices"
, Indices_function_type( &::gezi::Vector::Indices )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::Vector::Indices

typedef ::ivec & ( ::gezi::Vector::*Indices_function_type )(  ) ;

Vector_exposer.def(
"Indices"
, Indices_function_type( &::gezi::Vector::Indices )
, bp::return_internal_reference<>());

}
{ //::gezi::Vector::Init

typedef void ( ::gezi::Vector::*Init_function_type )( ::std::string,int,int,::std::string ) ;

Vector_exposer.def(
"Init"
, Init_function_type( &::gezi::Vector::Init )
, ( bp::arg("input"), bp::arg("startIndex")=(int)(0), bp::arg("length_")=(int)(0), bp::arg("sep")=",\011 " ) );

}
{ //::gezi::Vector::Init

typedef void ( ::gezi::Vector::*Init_function_type )( int,::std::vector< int > &,::std::vector< double > & ) ;

Vector_exposer.def(
"Init"
, Init_function_type( &::gezi::Vector::Init )
, ( bp::arg("length_"), bp::arg("indices_"), bp::arg("values_") ) );

}
{ //::gezi::Vector::Init

typedef void ( ::gezi::Vector::*Init_function_type )( ::std::vector< double > & ) ;

Vector_exposer.def(
"Init"
, Init_function_type( &::gezi::Vector::Init )
, ( bp::arg("values_") ) );

}
{ //::gezi::Vector::IsDense

typedef bool ( ::gezi::Vector::*IsDense_function_type )(  ) const;

Vector_exposer.def(
"IsDense"
, IsDense_function_type( &::gezi::Vector::IsDense ) );

}
{ //::gezi::Vector::IsSparse

typedef bool ( ::gezi::Vector::*IsSparse_function_type )(  ) const;

Vector_exposer.def(
"IsSparse"
, IsSparse_function_type( &::gezi::Vector::IsSparse ) );

}
{ //::gezi::Vector::Length

typedef int ( ::gezi::Vector::*Length_function_type )(  ) const;

Vector_exposer.def(
"Length"
, Length_function_type( &::gezi::Vector::Length ) );

}
{ //::gezi::Vector::MakeDense

typedef void ( ::gezi::Vector::*MakeDense_function_type )(  ) ;

Vector_exposer.def(
"MakeDense"
, MakeDense_function_type( &::gezi::Vector::MakeDense ) );

}
{ //::gezi::Vector::MakeSparse

typedef void ( ::gezi::Vector::*MakeSparse_function_type )(  ) ;

Vector_exposer.def(
"MakeSparse"
, MakeSparse_function_type( &::gezi::Vector::MakeSparse ) );

}
{ //::gezi::Vector::Norm

typedef ::Float ( ::gezi::Vector::*Norm_function_type )(  ) const;

Vector_exposer.def(
"Norm"
, Norm_function_type( &::gezi::Vector::Norm ) );

}
{ //::gezi::Vector::NumNonZeros

typedef int ( ::gezi::Vector::*NumNonZeros_function_type )(  ) ;

Vector_exposer.def(
"NumNonZeros"
, NumNonZeros_function_type( &::gezi::Vector::NumNonZeros ) );

}
{ //::gezi::Vector::PrepareDense

typedef void ( ::gezi::Vector::*PrepareDense_function_type )(  ) ;

Vector_exposer.def(
"PrepareDense"
, PrepareDense_function_type( &::gezi::Vector::PrepareDense ) );

}
{ //::gezi::Vector::Resize

typedef void ( ::gezi::Vector::*Resize_function_type )( int,::Float ) ;

Vector_exposer.def(
"Resize"
, Resize_function_type( &::gezi::Vector::Resize )
, ( bp::arg("length_"), bp::arg("value_")=0 ) );

}
{ //::gezi::Vector::ScaleBy

typedef void ( ::gezi::Vector::*ScaleBy_function_type )( ::Float ) ;

Vector_exposer.def(
"ScaleBy"
, ScaleBy_function_type( &::gezi::Vector::ScaleBy )
, ( bp::arg("d") ) );

}
{ //::gezi::Vector::SetIndex

typedef void ( ::gezi::Vector::*SetIndex_function_type )( int,int ) ;

Vector_exposer.def(
"SetIndex"
, SetIndex_function_type( &::gezi::Vector::SetIndex )
, ( bp::arg("index"), bp::arg("indexValue") ) );

}
{ //::gezi::Vector::SetLength

typedef void ( ::gezi::Vector::*SetLength_function_type )( int ) ;

Vector_exposer.def(
"SetLength"
, SetLength_function_type( &::gezi::Vector::SetLength )
, ( bp::arg("length_") ) );

}
{ //::gezi::Vector::SetValue

typedef void ( ::gezi::Vector::*SetValue_function_type )( int,::Float ) ;

Vector_exposer.def(
"SetValue"
, SetValue_function_type( &::gezi::Vector::SetValue )
, ( bp::arg("index"), bp::arg("value") ) );

}
{ //::gezi::Vector::Sparsify

typedef void ( ::gezi::Vector::*Sparsify_function_type )( ::Float ) ;

Vector_exposer.def(
"Sparsify"
, Sparsify_function_type( &::gezi::Vector::Sparsify )
, ( bp::arg("maxSparsity") ) );

}
{ //::gezi::Vector::Sparsify

typedef void ( ::gezi::Vector::*Sparsify_function_type )(  ) ;

Vector_exposer.def(
"Sparsify"
, Sparsify_function_type( &::gezi::Vector::Sparsify ) );

}
{ //::gezi::Vector::SquaredNorm

typedef ::Float ( ::gezi::Vector::*SquaredNorm_function_type )(  ) const;

Vector_exposer.def(
"SquaredNorm"
, SquaredNorm_function_type( &::gezi::Vector::SquaredNorm ) );

}
{ //::gezi::Vector::Str

typedef ::std::string ( ::gezi::Vector::*Str_function_type )( ::std::string ) const;

Vector_exposer.def(
"Str"
, Str_function_type( &::gezi::Vector::Str )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::Vector::Subtract

typedef void ( ::gezi::Vector::*Subtract_function_type )( ::gezi::Vector const & ) ;

Vector_exposer.def(
"Subtract"
, Subtract_function_type( &::gezi::Vector::Subtract )
, ( bp::arg("other") ) );

}
{ //::gezi::Vector::Swap

typedef void ( ::gezi::Vector::*Swap_function_type )( ::gezi::Vector & ) ;

Vector_exposer.def(
"Swap"
, Swap_function_type( &::gezi::Vector::Swap )
, ( bp::arg("other") ) );

}
{ //::gezi::Vector::ToDense

typedef void ( ::gezi::Vector::*ToDense_function_type )( ::std::vector< double > & ) ;

Vector_exposer.def(
"ToDense"
, ToDense_function_type( &::gezi::Vector::ToDense )
, ( bp::arg("values_") ) );

}
{ //::gezi::Vector::ToDense

typedef void ( ::gezi::Vector::*ToDense_function_type )(  ) ;

Vector_exposer.def(
"ToDense"
, ToDense_function_type( &::gezi::Vector::ToDense ) );

}
{ //::gezi::Vector::ToSparse

typedef void ( ::gezi::Vector::*ToSparse_function_type )(  ) ;

Vector_exposer.def(
"ToSparse"
, ToSparse_function_type( &::gezi::Vector::ToSparse ) );

}
{ //::gezi::Vector::Value

typedef ::Float ( ::gezi::Vector::*Value_function_type )( int ) const;

Vector_exposer.def(
"Value"
, Value_function_type( &::gezi::Vector::Value )
, ( bp::arg("index") ) );

}
{ //::gezi::Vector::Values

typedef ::std::vector< double > const & ( ::gezi::Vector::*Values_function_type )(  ) const;

Vector_exposer.def(
"Values"
, Values_function_type( &::gezi::Vector::Values )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::Vector::Values

typedef ::std::vector< double > & ( ::gezi::Vector::*Values_function_type )(  ) ;

Vector_exposer.def(
"Values"
, Values_function_type( &::gezi::Vector::Values )
, bp::return_internal_reference<>());

}
{ //::gezi::Vector::back

typedef ::Float ( ::gezi::Vector::*back_function_type )(  ) ;

Vector_exposer.def(
"back"
, back_function_type( &::gezi::Vector::back ) );

}
{ //::gezi::Vector::clear

typedef void ( ::gezi::Vector::*clear_function_type )(  ) ;

Vector_exposer.def(
"clear"
, clear_function_type( &::gezi::Vector::clear ) );

}
{ //::gezi::Vector::dot

typedef ::Float ( ::gezi::Vector::*dot_function_type )( ::gezi::Vector const & ) const;

Vector_exposer.def(
"dot"
, dot_function_type( &::gezi::Vector::dot )
, ( bp::arg("other") ) );

}
{ //::gezi::Vector::empty

typedef bool ( ::gezi::Vector::*empty_function_type )(  ) const;

Vector_exposer.def(
"empty"
, empty_function_type( &::gezi::Vector::empty ) );

}
{ //::gezi::Vector::erase

typedef void ( ::gezi::Vector::*erase_function_type )( ::__gnu_cxx::__normal_iterator< double*, std::vector< double > > ) ;

Vector_exposer.def(
"erase"
, erase_function_type( &::gezi::Vector::erase )
, ( bp::arg("pos") ) );

}
{ //::gezi::Vector::erase

typedef void ( ::gezi::Vector::*erase_function_type )( ::__gnu_cxx::__normal_iterator< double*, std::vector< double > >,::__gnu_cxx::__normal_iterator< double*, std::vector< double > > ) ;

Vector_exposer.def(
"erase"
, erase_function_type( &::gezi::Vector::erase )
, ( bp::arg("first"), bp::arg("last") ) );

}
{ //::gezi::Vector::front

typedef ::Float ( ::gezi::Vector::*front_function_type )(  ) ;

Vector_exposer.def(
"front"
, front_function_type( &::gezi::Vector::front ) );

}
{ //::gezi::Vector::insert

typedef ::__gnu_cxx::__normal_iterator< double*, std::vector< double > > ( ::gezi::Vector::*insert_function_type )( ::__gnu_cxx::__normal_iterator< double*, std::vector< double > >,::Float const & ) ;

Vector_exposer.def(
"insert"
, insert_function_type( &::gezi::Vector::insert )
, ( bp::arg("position"), bp::arg("val") ) );

}
{ //::gezi::Vector::operator()

typedef ::gezi::Vector & ( ::gezi::Vector::*__call___function_type )( int,::Float ) ;

Vector_exposer.def(
"__call__"
, __call___function_type( &::gezi::Vector::operator() )
, ( bp::arg("index"), bp::arg("value") )
, bp::return_internal_reference<>());

}
Vector_exposer.def( bp::self *= bp::other< Float >() );
Vector_exposer.def( bp::self += bp::self );
Vector_exposer.def( bp::self -= bp::self );
Vector_exposer.def( bp::self /= bp::other< Float >() );
{ //::gezi::Vector::operator=

typedef ::gezi::Vector & ( ::gezi::Vector::*assign_function_type )( ::gezi::Vector const & ) ;

Vector_exposer.def(
"assign"
, assign_function_type( &::gezi::Vector::operator= )
, ( bp::arg("arg0") )
, bp::return_self< >() );

}
{ //::gezi::Vector::operator[]

typedef ::Float ( ::gezi::Vector::*__getitem___function_type )( int ) const;

Vector_exposer.def(
"__getitem__"
, __getitem___function_type( &::gezi::Vector::operator[] )
, ( bp::arg("index") ) );

}
{ //::gezi::Vector::push_back

typedef void ( ::gezi::Vector::*push_back_function_type )( ::Float ) ;

Vector_exposer.def(
"push_back"
, push_back_function_type( &::gezi::Vector::push_back )
, ( bp::arg("item") ) );

}
{ //::gezi::Vector::resize

typedef void ( ::gezi::Vector::*resize_function_type )( int,::Float ) ;

Vector_exposer.def(
"resize"
, resize_function_type( &::gezi::Vector::resize )
, ( bp::arg("length_"), bp::arg("value_")=0 ) );

}
{ //::gezi::Vector::size

typedef ::size_t ( ::gezi::Vector::*size_function_type )(  ) const;

Vector_exposer.def(
"size"
, size_function_type( &::gezi::Vector::size ) );

}
{ //::gezi::Vector::str

typedef ::std::string ( ::gezi::Vector::*str_function_type )( ::std::string ) const;

Vector_exposer.def(
"str"
, str_function_type( &::gezi::Vector::str )
, ( bp::arg("sep")="," ) );

}
Vector_exposer.def_readwrite( "indices", &gezi::Vector::indices );
Vector_exposer.def_readwrite( "keepDense", &gezi::Vector::keepDense );
Vector_exposer.def_readwrite( "keepSparse", &gezi::Vector::keepSparse );
Vector_exposer.def_readwrite( "normalized", &gezi::Vector::normalized );
Vector_exposer.def_readwrite( "numNonZeros", &gezi::Vector::numNonZeros );
Vector_exposer.def_readwrite( "sparsityRatio", &gezi::Vector::sparsityRatio );
Vector_exposer.def_readwrite( "values", &gezi::Vector::values );
}
}
