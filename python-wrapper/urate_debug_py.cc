#define private public
#define protected public
#include "python_util.h"
// This file has been generated by Py++.

#include "boost/python.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "boost/python/suite/indexing/map_indexing_suite.hpp"

#include "common_util.h"

#include "feature/FeatureVector.h"

#include "tieba/urate/urate_info.h"

#include "tieba/urate/urate_features.h"

namespace bp = boost::python;

BOOST_PYTHON_MODULE(liburate_debug){
DEF_VEC(ivec);
DEF_VEC(dvec);
DEF_VEC(uvec);
DEF_VEC(svec);
DEF_VEC(ulvec);
DEF_MAP(id_map);
DEF_MAP(sd_map);
DEF_MAP(si_map);
DEF_MAP(ss_map);
DEF_PAIR(ii_pair);
DEF_PAIR(si_pair);
DEF_PAIR(wsi_pair);
DEF_VEC(si_pair_vec);
DEF_VEC(wsi_pair_vec);
DEF_SET(iset);
DEF_SET(lset);
DEF_SET(ulset);

{ //::std::vector< std::vector< std::string > >
typedef bp::class_< std::vector< std::vector< std::string > > > vector_less__std_scope_vector_less__std_scope_string__greater___greater__exposer_t;
vector_less__std_scope_vector_less__std_scope_string__greater___greater__exposer_t vector_less__std_scope_vector_less__std_scope_string__greater___greater__exposer = vector_less__std_scope_vector_less__std_scope_string__greater___greater__exposer_t( "vector_less__std_scope_vector_less__std_scope_string__greater___greater_" );
bp::scope vector_less__std_scope_vector_less__std_scope_string__greater___greater__scope( vector_less__std_scope_vector_less__std_scope_string__greater___greater__exposer );
//WARNING: the next line of code will not compile, because "::std::vector<std::string, std::allocator<std::string> >" does not have operator== !
//         vector_less__std_scope_vector_less__std_scope_string__greater___greater__exposer.def( bp::vector_indexing_suite< ::std::vector< std::vector< std::string > > >() );
}

{ //::std::vector< std::string >
typedef bp::class_< std::vector< std::string > > vector_less__std_scope_string__greater__exposer_t;
vector_less__std_scope_string__greater__exposer_t vector_less__std_scope_string__greater__exposer = vector_less__std_scope_string__greater__exposer_t( "vector_less__std_scope_string__greater_" );
bp::scope vector_less__std_scope_string__greater__scope( vector_less__std_scope_string__greater__exposer );
vector_less__std_scope_string__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< std::string >, true >() )
VEC_METHOD(::std::vector< std::string >);
}

{ //::std::vector< int >
typedef bp::class_< std::vector< int > > ivec_exposer_t;
ivec_exposer_t ivec_exposer = ivec_exposer_t( "ivec" );
bp::scope ivec_scope( ivec_exposer );
ivec_exposer.def( bp::vector_indexing_suite< ::std::vector< int >, true >() )
VEC_METHOD(::std::vector< int >);
}

{ //::std::vector< gezi::FeatureVector::Feature >
typedef bp::class_< std::vector< gezi::FeatureVector::Feature > > vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer_t;
vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer_t vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer = vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer_t( "vector_less__gezi_scope_FeatureVector_scope_Feature__greater_" );
bp::scope vector_less__gezi_scope_FeatureVector_scope_Feature__greater__scope( vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer );
vector_less__gezi_scope_FeatureVector_scope_Feature__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< gezi::FeatureVector::Feature > >() )
VEC_METHOD(::std::vector< gezi::FeatureVector::Feature >);
}

{ //::std::map< unsigned int, gezi::tieba::UserPostNumInfo >
typedef bp::class_< std::map< unsigned int, gezi::tieba::UserPostNumInfo > > map_less__unsigned_int_comma__gezi_scope_tieba_scope_UserPostNumInfo__greater__exposer_t;
map_less__unsigned_int_comma__gezi_scope_tieba_scope_UserPostNumInfo__greater__exposer_t map_less__unsigned_int_comma__gezi_scope_tieba_scope_UserPostNumInfo__greater__exposer = map_less__unsigned_int_comma__gezi_scope_tieba_scope_UserPostNumInfo__greater__exposer_t( "map_less__unsigned_int_comma__gezi_scope_tieba_scope_UserPostNumInfo__greater_" );
bp::scope map_less__unsigned_int_comma__gezi_scope_tieba_scope_UserPostNumInfo__greater__scope( map_less__unsigned_int_comma__gezi_scope_tieba_scope_UserPostNumInfo__greater__exposer );
//WARNING: the next line of code will not compile, because "::gezi::tieba::UserPostNumInfo" does not have operator== !
//         map_less__unsigned_int_comma__gezi_scope_tieba_scope_UserPostNumInfo__greater__exposer.def( bp::map_indexing_suite< ::std::map< unsigned int, gezi::tieba::UserPostNumInfo > >() );
}

{ //::std::map< std::string, gezi::tieba::UrlInfo >
typedef bp::class_< std::map< std::string, gezi::tieba::UrlInfo > > map_less__std_scope_string_comma__gezi_scope_tieba_scope_UrlInfo__greater__exposer_t;
map_less__std_scope_string_comma__gezi_scope_tieba_scope_UrlInfo__greater__exposer_t map_less__std_scope_string_comma__gezi_scope_tieba_scope_UrlInfo__greater__exposer = map_less__std_scope_string_comma__gezi_scope_tieba_scope_UrlInfo__greater__exposer_t( "map_less__std_scope_string_comma__gezi_scope_tieba_scope_UrlInfo__greater_" );
bp::scope map_less__std_scope_string_comma__gezi_scope_tieba_scope_UrlInfo__greater__scope( map_less__std_scope_string_comma__gezi_scope_tieba_scope_UrlInfo__greater__exposer );
map_less__std_scope_string_comma__gezi_scope_tieba_scope_UrlInfo__greater__exposer.def( bp::map_indexing_suite< ::std::map< std::string, gezi::tieba::UrlInfo > >() )
MAP_METHOD(::std::map< std::string COMMA  gezi::tieba::UrlInfo >);
}

{ //::gezi::FeatureVector
typedef bp::class_< gezi::FeatureVector > FeatureVector_exposer_t;
FeatureVector_exposer_t FeatureVector_exposer = FeatureVector_exposer_t( "FeatureVector", bp::init< gezi::FeatureVector const & >(( bp::arg("arg0") )) );
bp::scope FeatureVector_scope( FeatureVector_exposer );
{ //::gezi::FeatureVector::Feature
typedef bp::class_< gezi::FeatureVector::Feature > Feature_exposer_t;
Feature_exposer_t Feature_exposer = Feature_exposer_t( "Feature", bp::init< >() );
bp::scope Feature_scope( Feature_exposer );
Feature_exposer.def( bp::init< int, Float >(( bp::arg("index_"), bp::arg("value_") )) );
Feature_exposer.def( bp::init< int >(( bp::arg("index_") )) );
bp::implicitly_convertible< int, gezi::FeatureVector::Feature >();
Feature_exposer.def( bp::self == bp::self );
Feature_exposer.def_readwrite( "index", &gezi::FeatureVector::Feature::index );
Feature_exposer.def_readwrite( "value", &gezi::FeatureVector::Feature::value );
}
VEC_METHOD2(FeatureVector_exposer, gezi::FeatureVector);
FeatureVector_exposer.def( bp::init< bp::optional< bool > >(( bp::arg("useSparse")=(bool)(true) )) );
bp::implicitly_convertible< bool, gezi::FeatureVector >();
FeatureVector_exposer.def( bp::init< int >(( bp::arg("length_") )) );
bp::implicitly_convertible< int, gezi::FeatureVector >();
{ //::gezi::FeatureVector::Str

typedef ::std::string ( ::gezi::FeatureVector::*Str_function_type )( ::std::string ) ;

FeatureVector_exposer.def(
"Str"
, Str_function_type( &::gezi::FeatureVector::Str )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::FeatureVector::add

typedef void ( ::gezi::FeatureVector::*add_function_type )( ::Float,::std::string ) ;

FeatureVector_exposer.def(
"add"
, add_function_type( &::gezi::FeatureVector::add )
, ( bp::arg("value"), bp::arg("name")="" ) );

}
{ //::gezi::FeatureVector::add

typedef void ( ::gezi::FeatureVector::*add_function_type )( ::Float *,int,::std::string ) ;

FeatureVector_exposer.def(
"add"
, add_function_type( &::gezi::FeatureVector::add )
, ( bp::arg("values_"), bp::arg("len"), bp::arg("name")="" ) );

}
{ //::gezi::FeatureVector::add

typedef void ( ::gezi::FeatureVector::*add_function_type )( int,::Float ) ;

FeatureVector_exposer.def(
"add"
, add_function_type( &::gezi::FeatureVector::add )
, ( bp::arg("index"), bp::arg("value") ) );

}
{ //::gezi::FeatureVector::add_section

typedef void ( ::gezi::FeatureVector::*add_section_function_type )( ::std::string ) ;

FeatureVector_exposer.def(
"add_section"
, add_section_function_type( &::gezi::FeatureVector::add_section )
, ( bp::arg("name") ) );

}
{ //::gezi::FeatureVector::at

typedef ::Float ( ::gezi::FeatureVector::*at_function_type )( int ) const;

FeatureVector_exposer.def(
"at"
, at_function_type( &::gezi::FeatureVector::at )
, ( bp::arg("index") ) );

}
{ //::gezi::FeatureVector::clear

typedef void ( ::gezi::FeatureVector::*clear_function_type )(  ) ;

FeatureVector_exposer.def(
"clear"
, clear_function_type( &::gezi::FeatureVector::clear ) );

}
{ //::gezi::FeatureVector::count

typedef int ( ::gezi::FeatureVector::*count_function_type )(  ) const;

FeatureVector_exposer.def(
"count"
, count_function_type( &::gezi::FeatureVector::count ) );

}
{ //::gezi::FeatureVector::dimension

typedef int ( ::gezi::FeatureVector::*dimension_function_type )(  ) const;

FeatureVector_exposer.def(
"dimension"
, dimension_function_type( &::gezi::FeatureVector::dimension ) );

}
{ //::gezi::FeatureVector::empty

typedef bool ( ::gezi::FeatureVector::*empty_function_type )(  ) const;

FeatureVector_exposer.def(
"empty"
, empty_function_type( &::gezi::FeatureVector::empty ) );

}
{ //::gezi::FeatureVector::features

typedef ::std::vector< gezi::FeatureVector::Feature > & ( ::gezi::FeatureVector::*features_function_type )(  ) ;

FeatureVector_exposer.def(
"features"
, features_function_type( &::gezi::FeatureVector::features )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureVector::features

typedef ::std::vector< gezi::FeatureVector::Feature > const & ( ::gezi::FeatureVector::*features_function_type )(  ) const;

FeatureVector_exposer.def(
"features"
, features_function_type( &::gezi::FeatureVector::features )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::FeatureVector::finalize

typedef void ( ::gezi::FeatureVector::*finalize_function_type )(  ) ;

FeatureVector_exposer.def(
"finalize"
, finalize_function_type( &::gezi::FeatureVector::finalize ) );

}
{ //::gezi::FeatureVector::name_counts

typedef ::std::vector< int > & ( ::gezi::FeatureVector::*name_counts_function_type )(  ) ;

FeatureVector_exposer.def(
"name_counts"
, name_counts_function_type( &::gezi::FeatureVector::name_counts )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureVector::name_counts

typedef ::std::vector< int > const & ( ::gezi::FeatureVector::*name_counts_function_type )(  ) const;

FeatureVector_exposer.def(
"name_counts"
, name_counts_function_type( &::gezi::FeatureVector::name_counts )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::FeatureVector::names

typedef ::std::vector< std::string > & ( ::gezi::FeatureVector::*names_function_type )(  ) ;

FeatureVector_exposer.def(
"names"
, names_function_type( &::gezi::FeatureVector::names )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureVector::names

typedef ::std::vector< std::string > const & ( ::gezi::FeatureVector::*names_function_type )(  ) const;

FeatureVector_exposer.def(
"names"
, names_function_type( &::gezi::FeatureVector::names )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::FeatureVector::operator=

typedef ::gezi::FeatureVector & ( ::gezi::FeatureVector::*assign_function_type )( ::gezi::FeatureVector const & ) ;

FeatureVector_exposer.def(
"assign"
, assign_function_type( &::gezi::FeatureVector::operator= )
, ( bp::arg("arg0") )
, bp::return_self< >() );

}
{ //::gezi::FeatureVector::operator[]

typedef ::Float ( ::gezi::FeatureVector::*__getitem___function_type )( int ) const;

FeatureVector_exposer.def(
"__getitem__"
, __getitem___function_type( &::gezi::FeatureVector::operator[] )
, ( bp::arg("i") ) );

}
{ //::gezi::FeatureVector::section_names

typedef ::std::vector< std::string > & ( ::gezi::FeatureVector::*section_names_function_type )(  ) ;

FeatureVector_exposer.def(
"section_names"
, section_names_function_type( &::gezi::FeatureVector::section_names )
, bp::return_internal_reference<>());

}
{ //::gezi::FeatureVector::section_names

typedef ::std::vector< std::string > const & ( ::gezi::FeatureVector::*section_names_function_type )(  ) const;

FeatureVector_exposer.def(
"section_names"
, section_names_function_type( &::gezi::FeatureVector::section_names )
, bp::return_value_policy< bp::copy_const_reference >() );

}
{ //::gezi::FeatureVector::str

typedef ::std::string ( ::gezi::FeatureVector::*str_function_type )( ::std::string ) ;

FeatureVector_exposer.def(
"str"
, str_function_type( &::gezi::FeatureVector::str )
, ( bp::arg("sep")="," ) );

}
{ //::gezi::FeatureVector::value_at

typedef ::Float ( ::gezi::FeatureVector::*value_at_function_type )( int ) const;

FeatureVector_exposer.def(
"value_at"
, value_at_function_type( &::gezi::FeatureVector::value_at )
, ( bp::arg("index") ) );

}
}

bp::class_< gezi::PyFeatures, bp::bases< gezi::FeatureVector > >( "PyFeatures" );

bp::class_< gezi::tieba::UrateInfo >( "UrateInfo" )
.def(
"IsValid"
, (bool ( ::gezi::tieba::UrateInfo::* )(  ) )( &::gezi::tieba::UrateInfo::IsValid ) )
.def(
"size"
, (::size_t ( ::gezi::tieba::UrateInfo::* )(  ) )( &::gezi::tieba::UrateInfo::size ) )
.def(
"type"
, (int ( ::gezi::tieba::UrateInfo::* )(  ) )( &::gezi::tieba::UrateInfo::type ) )
.def_readwrite( "imginfo", &gezi::tieba::UrateInfo::imginfo )
.def_readwrite( "isWhiteTitle", &gezi::tieba::UrateInfo::isWhiteTitle )
.def_readwrite( "nowPostInfo", &gezi::tieba::UrateInfo::nowPostInfo )
.def_readwrite( "postId", &gezi::tieba::UrateInfo::postId )
.def_readwrite( "postsInfo", &gezi::tieba::UrateInfo::postsInfo )
.def_readwrite( "urlInfoMap", &gezi::tieba::UrateInfo::urlInfoMap )
.def_readwrite( "urlsVec", &gezi::tieba::UrateInfo::urlsVec )
.def_readwrite( "userInfo", &gezi::tieba::UrateInfo::userInfo )
.def_readwrite( "userLikeForumInfo", &gezi::tieba::UrateInfo::userLikeForumInfo )
.def_readwrite( "userPostNumInForum", &gezi::tieba::UrateInfo::userPostNumInForum )
.def_readwrite( "userPostNumInfo", &gezi::tieba::UrateInfo::userPostNumInfo );

{ //::gezi::tieba::add_urate_features

typedef void ( *add_urate_features_function_type )( ::gezi::FeaturesExtractorMgr & );

bp::def(
"add_urate_features"
, add_urate_features_function_type( &::gezi::tieba::add_urate_features )
, ( bp::arg("mgr") ) );

}

{ //::gezi::tieba::adjust

typedef void ( *adjust_function_type )( double &,::gezi::tieba::UrateInfo const & );

bp::def(
"adjust"
, adjust_function_type( &::gezi::tieba::adjust )
, ( bp::arg("score"), bp::arg("uinfo") ) );

}

{ //::gezi::tieba::gen_urate_features

typedef ::gezi::Features ( *gen_urate_features_function_type )( ::uint64,::gezi::tieba::UrateInfo &,::std::string,bool,bool,int );

bp::def(
"gen_urate_features"
, gen_urate_features_function_type( &::gezi::tieba::gen_urate_features )
, ( bp::arg("pid"), bp::arg("info"), bp::arg("historyPath")="./history", bp::arg("useFetch")=(bool)(true), bp::arg("forceFetch")=(bool)(false), bp::arg("historyNum")=(int)(25) ) );

}

{ //::gezi::tieba::gen_urate_features

typedef ::gezi::Features ( *gen_urate_features_function_type )( ::uint64,::std::string,bool,bool,int );

bp::def(
"gen_urate_features"
, gen_urate_features_function_type( &::gezi::tieba::gen_urate_features )
, ( bp::arg("pid"), bp::arg("historyPath")="./history", bp::arg("useFetch")=(bool)(true), bp::arg("forceFetch")=(bool)(false), bp::arg("historyNum")=(int)(25) ) );

}

{ //::gezi::tieba::get_urate_info_str

typedef ::std::string ( *get_urate_info_str_function_type )( ::gezi::tieba::UrateInfo const & );

bp::def(
"get_urate_info_str"
, get_urate_info_str_function_type( &::gezi::tieba::get_urate_info_str )
, ( bp::arg("info") ) );

}
}
